FUNCTION_BLOCK "example_abb_aquaMaster_3"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      device : "udt_mb_device";
      flow : Real;
      pressure : Real;
      totaliser : Struct
         fwd : DWord;
         rev : DWord;
         net : DWord;
      END_STRUCT;
   END_VAR


BEGIN
	// - ABB - AquaMaster 3 - Electromagnetic flowmeter
	// - COI/FET2XX/MOD/TBL–EN
	// - https://library.e.abb.com/public/
	//   91eead459bb0d349c12577fc0033d2b5/COI_FET2XX_MOD_TBL-EN.pdf
	// - Example code, no test with equipment done.
	
	"mb_device_header"(device := #device, mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_input_reg,
	           d_addr := 5017,
	           d_len := 2,
	           data := #flow,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_input_reg,
	           d_addr := 5025,
	           d_len := 2,
	           data := #pressure,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 12003,
	           d_len := #mb.c.auto_len,
	           data := #totaliser,
	           mb := #mb);
	
	"mb_device_footer"(device := #device, mb := #mb);
	
	IF #device.qComError THEN
	    #flow := 0;
	    #pressure := 0;
	END_IF;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "modbus_device_start_example"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt := 1;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      device : "udt_mb_device";
      query_1 : Struct
         word_1 : Word;
         word_2 : Word;
      END_STRUCT;
      query_2 : Array[1..2] of Word;
      conditon_of_exec_query_4 : Bool;
      query_3 : Word;
      query_4 : Word;
   END_VAR


BEGIN
	// Start example for a device blocks. A device block is a FB 
	// that is written for one spesific modbus device. It maps
	// registers of the device to variables inside the FB.
	// Simular to a gsd-file for profibus.
	
	
	// Just igone the mb_device_header for now. It isn't a
	// hundred percent necessary, but give advantageses.
	"mb_device_header"(device := #device, mb := #mb);
	
	
	// The query bellow read data from a device with the device address
	// "#unit" staring at holding register with address "d_addr". Two words
	// are read becouse the #query_1 structure contains two words. The
	// length of the querie is automatically calculated from the number of
	// bytes in the data parameter. The structure of the #query_1 has to be
	// customized for each querie, to match the data of the register in the
	// device. And of course the d_addr param has to be set.
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 123,
	           d_len := #mb.c.auto_len,
	           data := #query_1,
	           mb := #mb);
	
	// A standard modbus telegram:     
	// .------.------.------------.------------.--  ..  ..  -- --.------------.
	// | unit |  fc  |   d_addr   |   d_len    |      data       |    CRC     |
	// '------'------'------------'------------'-- --  ..  ..  --'------------'
	// 
	// Keep in mind that the value of "d_addr" will be the acctual value inside
	// the modbus telegram. Eg. to read holding address 123 in the device, you
	// simply pass 123 to d_addr and 3 [read_holding_reg] to the fc-param.
	// Don't add 40001 to 123 as with the tia-portal mb_master or mb_client
	// block.
	// 
	// When the read query is sucssefully executed the content of the  modbus
	// telegram will be written in to the varable connected to data-param.
	// Equally the conntent of the varable will be sent to a modbus device when
	// a write query is executed.
	//
	// Regards the d_len parameter, it's easiest to just type #mb.c.auto_len,
	// and the library will calculate the length automatacally based on how
	// many words the data-parameter consist of. The library, will run a
	// little faster if the d_len parameter is typed manually.
	
	
	// Simular querie as above, except two input register are read. By
	// start typing <<#mb.fc.>> is possible to see all the available
	// function codes in the autocomplete list that are supported.
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_input_reg,
	           d_addr := 0,
	           d_len := #mb.c.auto_len,
	           data := #query_2,
	           mb := #mb);
	
	
	// An other example. Any number of queries can be added,
	// the library will take care of executing them, one by one.
	"mb_query"(unit := #unit,
	           fc := #mb.fc.write_output_bits,
	           d_addr := 0,
	           d_len := #mb.c.auto_len,
	           data := #query_3,
	           mb := #mb);
	
	
	// A query that has a condition for execution.
	IF #conditon_of_exec_query_4 THEN
	    "mb_query"(unit := #unit,
	               fc := #mb.fc.write_holding_reg,
	               d_addr := 0,
	               d_len := #mb.c.auto_len,
	               data := #query_4,
	               mb := #mb);
	END_IF;
	// The condition for the querie above will work. However is recommaned
	// that the example bellow is followed if a condition for a querie is 
	// needed. Every time the number of queries is changed, the
	// library is getting a little "hiccup". That can be avoided by doing as
	// showen bellow. Though, the example above will work perfectly fine.
	"mb_query"(unit := #unit,
	           fc := SEL(G := #conditon_of_exec_query_4,
	                     IN0 := #mb.fc.skip_query,
	                     IN1 := #mb.fc.write_holding_reg),
	           d_addr := 0,
	           d_len := #mb.c.auto_len,
	           data := #query_4,
	           mb := #mb);
	
	// keep in mind that the data-parameter is not limited to words, but
	// can contain any complex data structure with all kind of dattypes.
	// Likes reals, bool, bytes, arrays, etc. The only rule that need to
	// be followedis, is that the structure has add up the whole words
	// (16 bits). Also the modbus protocol limit each query to maximum
	// of 123 words. (Sometimes up to 125 words)
	
	
	// If the siemens modes are preferred, they are still available.
	"mb_query"(unit := #unit,
	           fc := #mb.fc.mode_read,
	           d_addr := 0,
	           d_len := #mb.c.auto_len,
	           data := #query_4,
	           mb := #mb);
	// Just keep in mind that the modes are shifted: 200 for mode 0, 201
	// for mode 1, and 202 for mode 2. By using the constants inside
	// #mb.fc this is automaticaly taken care of. When the Siemens modes
	// are used, function code is "embedded" to the d_addr. Eg. query
	// 40005 will acctually query holding register with address 4.
	
	
	// As mession at the top the mb_device_header is not a hundred percent
	// necessary. Hovever, if the mb_device_header is implemented then the
	// mb_device_footer has to be implement as well. Else the library will
	// not work. No query should go after mb_device_footer or before
	// the mb_device_header.
	"mb_device_footer"(
	    device := #device, // udt_device                  
	    mb := #mb); // udt_mb
	
	// This are the bennefits of using the device header and the footer FC's:
	//  - First of all they will make sure that the queries
	//    between them are skipped if a timeout is detected at one querie.
	//    A new atempted to execute a querie is done after all other queries
	//    that bellong to the mb-udt is done. This will speed up a 
	//    application a lot, if a device is disconnected.
	//  - An other big bennefit is the logging capacities. Inside the
	//    device-udt there is logging of sucessfull and failed queries, which
	//    is very helpfull for debugging. Look inside the log-structure of the
	//    device udt.
	//  - Last but not least, the device udt has some common error flags, that
	//    will be set if any of the intermediate queries gives an error.
	//    quite handy as you can se bellow.
	
	
	// For this example values are set to zero if communcation problems accure.
	IF #device.qComError THEN
	    #query_1.word_1 := 0;
	    #query_1.word_2 := 0;
	    
	    #query_2[1] := 0;
	    #query_2[2] := 0;
	END_IF;
END_FUNCTION_BLOCK

DATA_BLOCK "modbus_rtu_buffer"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
NON_RETAIN
   STRUCT 
      buffer : Array[0..125] of Word;
   END_STRUCT;


BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "example_novus_tht"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt;
   END_VAR

   VAR_OUTPUT 
      temperature : Int;
      humidity : Int;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      device : "udt_mb_device";
      serial_number : DWord;
      raw_values { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : Struct
         temp { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : Int;
         hum { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : Int;
      END_STRUCT;
   END_VAR


BEGIN
	// - Novus - RHT (Temperature transmitter)
	// - http://www.novusautomation.com/downloads/Arquivos/
	//   v10x_b_manual_rht_wm-dm-p10_485_lcd_%20english.pdf
	// - Example code, no test with equipment done.
	
	"mb_device_header"(device := #device, mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 7,
	           d_len := #mb.c.auto_len,
	           data := #raw_values,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 0,
	           d_len := #mb.c.auto_len,
	           data := #serial_number,
	           mb := #mb);
	
	"mb_device_footer"(device := #device, mb := #mb);
	
	IF #device.qComError THEN
	    #serial_number := 0;
	    #raw_values.temp := 0;
	    #raw_values.hum := 0;
	END_IF;
	
	#temperature := #raw_values.temp / 10;
	#humidity := #raw_values.hum / 10;
	
END_FUNCTION_BLOCK

DATA_BLOCK "modbus_tcp_buffer"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
NON_RETAIN
   STRUCT 
      buffer : Array[0..125] of Word;
   END_STRUCT;


BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "modbus_rtu_start_example"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      mb : "udt_mb";
      mb_rtu_controller : "mb_rtu_controller";
      device_start_example_device1 : "modbus_device_start_example";
      device_start_example_device2 : "modbus_device_start_example";
      device_start_example_device3 : "modbus_device_start_example";
      example_novus_tht_device1 : "example_novus_tht";
      example_novus_tht_device2 : "example_novus_tht";
      example_abb_aquaMaster_3_device1 : "example_abb_aquaMaster_3";
      example_abb_aquaMaster_3_device2 : "example_abb_aquaMaster_3";
   END_VAR


BEGIN
	#mb_rtu_controller(
	    hardware_id := "Local~CB_1241_(RS485)", 
	    baud := 9600, // bps
	    parity := true, // Enable even parity.
	    timeout := T#500ms,   
	    buffer_db_any := "modbus_rtu_buffer",  
	    buffer_variant := "modbus_rtu_buffer",  
	    mb := #mb );
	
	// In this rtu example there are 7 devices (units) connected to the
	// modbus rtu bus. Each instance of the blocks bellow represent 
	// one unit on the line. In this way is very easy to reuse 
	// code once there has been created a "device block" for one 
	// device.
	
	// Open the start example to see how a device block is created.
	// ( unit => device-address ) 
	#device_start_example_device1(unit := 1, mb := #mb);
	#device_start_example_device2(unit := 2, mb := #mb);
	#device_start_example_device3(unit := 3, mb := #mb);
	
	// Two novus tht temperatur transmitters.
	#example_novus_tht_device1(unit := 4, mb := #mb);
	#example_novus_tht_device2(unit := 5, mb := #mb);
	
	// Two abb aqua master 3 devices.
	#example_abb_aquaMaster_3_device1(unit := 6, mb := #mb);
	#example_abb_aquaMaster_3_device2(unit := 7, mb := #mb);
	
	// Keep in mind that a device block can be used both for modbus rtu
	// and tcp. This is specially useful if a tcp-rtu-gateway is used.
	// The same program could be used, just swap the rtu controller, with
	// the tcp controller.
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "modbus_tcp_start_example"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      mb : "udt_mb";
      mb_tcp_controller : "mb_tcp_controller";
      device_start_example : "modbus_device_start_example";
   END_VAR


BEGIN
	#mb_tcp_controller.ip_addr[1] := 192;
	#mb_tcp_controller.ip_addr[2] := 168;
	#mb_tcp_controller.ip_addr[3] := 1;
	#mb_tcp_controller.ip_addr[4] := 2;
	#mb_tcp_controller(
	    interface := "Local~PROFINET_interface_1",
	    conn_id := 123, 
	    tcp_port := 502,  
	    timeout := T#2s,
	    buffer_db_any := "modbus_tcp_buffer",  
	    buffer_variant := "modbus_tcp_buffer", 
	    mb := #mb);
	
	// - interface:      Ethernet port to be used The const. is found
	//                   inside the "hardware configuration".              
	// - conn_id:        A unique id for each tcp connectin in the plc.
	// - tcp_port:       502 is the standard modbus tcp port.
	// - timeout:
	// - buffer_db_any:  A db with standard access consisting a array of 125 words.
	// - buffer_variant: Input the same variable as above.
	// - udt_mb:         The udt is the link the controller to its belonging queries.
	
	
	#device_start_example(
	    unit := 1, // device address. For tcp devices unit can usually be set to "1".                                  
	    mb := #mb);
	
	// Note that a device block cen be used for both tcp and rtu. This of
	// course require that the device has interface or a interface extension,
	// for both for Ethernet and RS-485. (Or a RS-485 alternativ)
	
	// If a tcp-rtu-gateway is used, then more device blocks can be placed here
	// as in the rtu example.
	
	
END_FUNCTION_BLOCK

DATA_BLOCK "modbus_tcp_start_example_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"modbus_tcp_start_example"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "modbus_rtu_start_example_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"modbus_rtu_start_example"

BEGIN

END_DATA_BLOCK

ORGANIZATION_BLOCK "rtu_ob"
TITLE = "Main Program Sweep (Cycle)"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	
	// Open the block to see the example.
	"modbus_rtu_start_example_DB"();
	
END_ORGANIZATION_BLOCK

FUNCTION "readme" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	(*
	Readme.
	------------
	
	The software is written for both S7-1200 and S7-1500 series, but unfortunately not 
	for S7-300 and S7-400 series. 
	
	Requirements:
	 - TIA-portal: v13, sp1, upd8 (or greater)
	 - S7-1200: firmware version >= 4.1.3
	
	If the library is only used for rtu then all blocks related to tcp should be removed 
	to save memory in the PLC. Equally all rtu blocks should be removed if the library
	is only used for tcp. Also all the example device blocks can be removed to save 
	memory.
	
END_FUNCTION

ORGANIZATION_BLOCK "tcp_ob"
TITLE = "Main Program Sweep (Cycle)"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	
	// Open the block to see the example.
	"modbus_tcp_start_example_DB"();
	
END_ORGANIZATION_BLOCK

FUNCTION_BLOCK "example_sm"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt := 1;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      query_1 : Word;
      query_2 : Word;
      query_3 : Word;
      state : SInt;
   END_VAR


BEGIN
	// This is an advanced example which most users don't need to
	// worry about. Read "modbus_device_start_example" before
	// reading this example.
	// 
	// If there is a need of forcing some queries to be executed
	// in a given order, then the example bellow should be followed.
	
	CASE #state OF
	    0:
	        "mb_query"(unit := #unit,
	                   fc := #mb.fc.write_holding_reg,
	                   d_addr := 123,
	                   d_len := #mb.c.auto_len,
	                   data := #query_1,
	                   mb := #mb);
	        #state := #state + BOOL_TO_SINT(#mb.query_above.done);
	        // "#mb.query_above.done" is true if the query above
	        // in the code just finnished a sucessfull query.
	        // There is also "#mb.query_above.error" to check if
	        // the query above resualted in an error.    
	    1:
	        "mb_query"(unit := #unit,
	                   fc := #mb.fc.write_holding_reg,
	                   d_addr := 456,
	                   d_len := #mb.c.auto_len,
	                   data := #query_2,
	                   mb := #mb);
	        #state := #state + BOOL_TO_SINT(#mb.query_above.done);
	    2:
	        "mb_query"(unit := #unit,
	                   fc := #mb.fc.read_holding_reg,
	                   d_addr := 789,
	                   d_len := #mb.c.auto_len,
	                   data := #query_3,
	                   mb := #mb);
	        #state := #state + BOOL_TO_SINT(#mb.query_above.done);
	END_CASE;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "example_siemens_PAC3200"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      device : "udt_mb_device";
      current : Struct
         a : Real;   // unit: A
         b : Real;   // unit: A
         c : Real;   // unit: A
      END_STRUCT;
      common : Struct
         frequency : Real;   // unit: hz
         avg_voltage_Vph_n : Real;   // unit: V
         avg_voltage_Vph_ph : Real;   // unit: V
         avg_current : Real;   // unit: A
         total_apparent_power : Real;   // unit: VA
         total_active_power : Real;   // unit: W
      END_STRUCT;
   END_VAR


BEGIN
	// - Siemens - PAC3200
	// - http://w3.siemens.com.br/buildingtechnologies/br/
	//   documents/manual-sentron-pac3200.pdf
	//   3.9.3, page 40
	// - Example code, no test with equipment done.
	
	"mb_device_header"(device := #device, mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 13,
	           d_len := #mb.c.auto_len,
	           data := #current,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 55,
	           d_len := #mb.c.auto_len,
	           data := #common,
	           mb := #mb);
	
	"mb_device_footer"(device := #device, mb := #mb);
END_FUNCTION_BLOCK

