FUNCTION_BLOCK "example_abb_aquaMaster_3"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      device_udt : "udt_mb_device";
      flow : Real;
      pressure : Real;
      totaliser : Struct
         fwd : DWord;
         rev : DWord;
         net : DWord;
      END_STRUCT;
   END_VAR


BEGIN
	// - ABB - AquaMaster 3 - Electromagnetic flowmeter
	// - COI/FET2XX/MOD/TBL–EN
	// - https://library.e.abb.com/public/91eead459bb0d349c12577fc0033d2b5/COI_FET2XX_MOD_TBL-EN.pdf
	// - Example code, no test with equipment done.
	
	"mb_device_header"(device := #device_udt, mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_input_reg,
	           d_addr := 5017,
	           d_len := 2,
	           data := #flow,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_input_reg,
	           d_addr := 5025,
	           d_len := 2,
	           data := #pressure,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 12003,
	           d_len := #mb.c.auto_len,
	           data := #totaliser,
	           mb := #mb);
	
	"mb_device_footer"(device := #device_udt, mb := #mb);
	
	IF #device_udt.qComError THEN
	    #flow := 0;
	    #pressure := 0;
	END_IF;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "modbus_device_start_example"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt := 1;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      device_udt : "udt_mb_device";
      resault_data_query_1 : Struct
         word_1 : Word;
         word_2 : Word;
      END_STRUCT;
      resault_data_query_2 : Array[1..2] of Word;
      conditon_of_exec_query_4 : Bool;
      data_query_3 : Word;
      data_query_4 : Word;
   END_VAR


BEGIN
	// Start example for a device blocks. A device block is a FB  that is
	// written for one spesific modbus device. It maps registers of the
	// device to variables inside the FB. Simular to a gsd-file for profibus.
	
	
	// Just ignore the mb_device_header for now. It isn't a hundred percent
	// necessary, but give advantageses.
	"mb_device_header"(device := #device_udt, mb := #mb);
	
	
	// The query bellow read data from a device with the device address
	// "#unit" staring at holding register with address 123. Two words
	// are read becouse the #query_1 structure contains two words. The
	// length of the querie is automatically calculated from the number of
	// bytes in the data parameter. The structure of the #query_1 has to be
	// customized for each querie, to match the data of the register in the
	// device. And of course the d_addr param has to be set.
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 123,
	           d_len := #mb.c.auto_len,
	           data := #resault_data_query_1,
	           mb := #mb);
	
	// A standard modbus telegram:     
	// .------.------.------------.------------.--  ..  ..  -- --.------------.
	// | unit |  fc  |   d_addr   |   d_len    |      data       |    CRC     |
	// '------'------'------------'------------'-- --  ..  ..  --'------------'
	// 
	// Keep in mind that the value of "d_addr" will be the acctual value inside
	// the modbus telegram. Eg. to read holding address 123 in the device, you
	// simply pass 123 to d_addr and 3 [read_holding_reg] to the fc-param.
	// Don't add 40001 to 123 as with the tia-portal mb_master or mb_client
	// block.
	// 
	// When the read query is sucssefully executed the content of the  modbus
	// telegram will be written in to the varable connected to data-param.
	// Equally the conntent of the varable will be sent to a modbus device when
	// a write query is executed.
	//
	// Regards the d_len parameter, it's easiest to just type #mb.c.auto_len,
	// and the library will calculate the length automatacally based on how
	// many words the data-parameter consist of. The library, will run a little
	// faster if the d_len parameter is typed manually.
	
	
	// Simular querie as above, except two input register are read. By start
	// typing <<#mb.fc.>> is possible to see all the available function codes
	// in the autocomplete list that are supported.
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_input_reg,
	           d_addr := 0,
	           d_len := #mb.c.auto_len,
	           data := #resault_data_query_2,
	           mb := #mb);
	
	
	// An other example. Any number of queries can be added, the library will
	// take care of executing them, one by one.
	"mb_query"(unit := #unit,
	           fc := #mb.fc.write_output_bits,
	           d_addr := 1234,
	           d_len := #mb.c.auto_len,
	           data := #data_query_3,
	           mb := #mb);
	
	
	// keep in mind that the data-parameter is not limited to words, but can
	// contain any complex data structure with all kind of dattypes. Likes
	// reals, bool, bytes, arrays, etc. The only rule that need to be
	// followedis, is that the structure has add up the whole words (16 bits).
	// Also the modbus protocol limit each query to maximum OF 123 words.
	// (Sometimes up to 125 words)
	
	
	// A query that has a condition for execution.
	IF #conditon_of_exec_query_4 THEN
	    "mb_query"(unit := #unit,
	               fc := #mb.fc.write_holding_reg,
	               d_addr := 12345,
	               d_len := #mb.c.auto_len,
	               data := #data_query_4,
	               mb := #mb);
	END_IF;
	// The condition for the querie above will work. However is recommaned that
	// the example bellow is followed if a condition for a querie is needed.
	// Every time the number of queries is changed, the library is getting a
	// little "hiccup". That can be avoided by doing as showen bellow. Though,
	// the example above will mostly work perfectly fine.
	"mb_query"(unit := #unit,
	           fc := SEL(G := #conditon_of_exec_query_4,
	                     IN0 := #mb.fc.skip_query,
	                     IN1 := #mb.fc.write_holding_reg),
	           d_addr := 12345,
	           d_len := #mb.c.auto_len,
	           data := #data_query_4,
	           mb := #mb);
	// The "hiccup": If a reasult is waiting while the number of queries
	// is changing, then it may not be picked up, and the query has to
	// wait until all the other queries has been executed once more. If
	// the condition change rappedly on and off, then the first example
	// will not work and the secound example need to be followed.
	
	
	// If the siemens modes are preferred, they are still available.
	"mb_query"(unit := #unit,
	           fc := #mb.fc.mode_read,
	           d_addr := 40005,
	           d_len := #mb.c.auto_len,
	           data := #data_query_4,
	           mb := #mb);
	// Keep in mind that the modes are shifted: 200 for mode 0, 201 for
	// mode 1, and 202 for mode 2. By using the constants inside "#mb.fc." this
	// is automaticaly taken care of. When the Siemens modes are used, function
	// code is "embedded" to the d_addr. Eg. query 40005 will acctually query
	// holding register with address 4.
	
	
	// As mession at the top the mb_device_header is not a hundred percent
	// necessary. Hovever, if the mb_device_header is implemented then the
	// mb_device_footer has to be implement as well. Else the library will not
	// work. No query should go before mb_device_header or after
	// mb_device_footer.
	"mb_device_footer"(
	    device := #device_udt, // device_udt
	    mb := #mb); // mb_udt
	
	// This are the bennefits of using the device header and the footer FC's:
	//  - The logging capacities: Inside the device-udt there is logging of
	//    sucessfull and failed queries, which is helpfull
	//    for debugging. Look at "#device_udt.log. ..."
	//  - "#device_udt.qError" a common error flag that is set if any of the
	//    intermediate queries between mb_device_footer and mb_device_header
	//    gives a error. This flag is intended for use with HMI. The puls
	//    lenght of the flag can be configured with
	//    "#device_udt.config.time_qErrror".
	//  - "#device_udt.qComError" a error flag that will be set after number
	//    of repeating timeout of the intermediate queries. Intended to reset
	//    values when communication problems occure. The number of repeating
	//    timeout before the flag is set can be configured with
	//    "#device_udt.config.max_qComError".
	//  - Advaced timeout handler: All intermediate queries will be skipped
	//    if a timeout occured at one intermediate query. A new atempted will
	//    be done after all other queries has been executed once. This
	//    speed up the bus significantly if one or more devices are
	//    disconnected.
	//    If a number of timeouts occure, and the "#device_udt.qComError" flag
	//    is set, then a new atemptes will be delayed even longer, based on
	//    timeouts from other devices.
	
	
	// For this example values are set to zero if communcation problems accure.
	IF #device_udt.qComError THEN
	    #resault_data_query_1.word_1 := 0;
	    #resault_data_query_1.word_2 := 0;
	    
	    #resault_data_query_2[1] := 0;
	    #resault_data_query_2[2] := 0;
	END_IF;
END_FUNCTION_BLOCK

DATA_BLOCK "modbus_rtu_buffer"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
NON_RETAIN
   STRUCT 
      buffer : Array[0..125] of Word;
   END_STRUCT;


BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "example_novus_tht"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt;
   END_VAR

   VAR_OUTPUT 
      temperature : Int;
      humidity : Int;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      device_udt : "udt_mb_device";
      serial_number : DWord;
      raw_values { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : Struct
         temp { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : Int;
         hum { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : Int;
      END_STRUCT;
   END_VAR


BEGIN
	// - Novus - RHT (Temperature transmitter)
	// - http://www.novusautomation.com/downloads/Arquivos/v10x_b_manual_rht_wm-dm-p10_485_lcd_%20english.pdf
	// - Example code, no test with equipment done.
	
	"mb_device_header"(device := #device_udt, mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 7,
	           d_len := #mb.c.auto_len,
	           data := #raw_values,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 0,
	           d_len := #mb.c.auto_len,
	           data := #serial_number,
	           mb := #mb);
	
	"mb_device_footer"(device := #device_udt, mb := #mb);
	
	IF #device_udt.qComError THEN
	    #serial_number := 0;
	    #raw_values.temp := 0;
	    #raw_values.hum := 0;
	END_IF;
	
	#temperature := #raw_values.temp / 10;
	#humidity := #raw_values.hum / 10;
	
END_FUNCTION_BLOCK

DATA_BLOCK "modbus_tcp_buffer"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
NON_RETAIN
   STRUCT 
      buffer : Array[0..125] of Word;
   END_STRUCT;


BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "modbus_rtu_start_example"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      mb : "udt_mb";
      mb_rtu_controller : "mb_master_controller";
      device_start_example_device1 : "modbus_device_start_example";
      device_start_example_device2 : "modbus_device_start_example";
      device_start_example_device3 : "modbus_device_start_example";
      example_novus_tht_device1 : "example_novus_tht";
      example_novus_tht_device2 : "example_novus_tht";
      example_abb_aquaMaster_3_device1 : "example_abb_aquaMaster_3";
      example_abb_aquaMaster_3_device2 : "example_abb_aquaMaster_3";
      resault_data_1 : Word;
   END_VAR


BEGIN
	#mb_rtu_controller(
	    hardware_id := "Local~CB_1241_(RS485)", // Setup the rtu-line in the hardware configurator
	    baud := 9600, // bps
	    parity := true, // Enable even parity. (Odd parity is not available)
	    timeout := T#500ms,   
	    buffer_db_any := "modbus_rtu_buffer",  
	    buffer_variant := "modbus_rtu_buffer",  
	    mb := #mb );
	
	// In this rtu example there are 7 devices (units) connected to the
	// modbus rtu bus. Each instance of the blocks bellow represent 
	// one unit on the line. In this way is very easy to reuse code once
	// there has been created a "device block" for one device.
	
	// Open the start example to see how a device block is created.
	// ( unit => device-address ) 
	#device_start_example_device1(unit := 1, mb := #mb);
	#device_start_example_device2(unit := 2, mb := #mb);
	#device_start_example_device3(unit := 3, mb := #mb);
	
	// Two novus tht temperatur transmitters.
	#example_novus_tht_device1(unit := 4, mb := #mb);
	#example_novus_tht_device2(unit := 5, mb := #mb);
	
	// Two abb aqua master 3 devices.
	#example_abb_aquaMaster_3_device1(unit := 6, mb := #mb);
	#example_abb_aquaMaster_3_device2(unit := 7, mb := #mb);
	
	// Keep in mind that a device block can be used both for modbus rtu
	// and tcp. This is specially useful if a tcp-rtu-gateway is used.
	// The same program could be used, just swap the rtu controller, with
	// the tcp controller.
	
	
	// Read holding register 456 from device with unit address 123.
	// This is an example of that a query does not necessarily need
	// to be inside a device block as obove, however making reusable
	// device blocks is good practice.
	"mb_query"(unit := 123,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 456,
	           d_len := #mb.c.auto_len,
	           data := #resault_data_1,
	           mb := #mb);
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "modbus_tcp_start_example"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      mb : "udt_mb";
      mb_tcp_controller : "mb_client_controller";
      device_start_example : "modbus_device_start_example";
      resault_data_1 : Word;
   END_VAR


BEGIN
	// The ip-address of the server, the client will communicate with.
	#mb_tcp_controller.ip_addr[1] := 192;
	#mb_tcp_controller.ip_addr[2] := 168;
	#mb_tcp_controller.ip_addr[3] := 1;
	#mb_tcp_controller.ip_addr[4] := 2;
	
	#mb_tcp_controller(
	    interface := "Local~PROFINET_interface_1",
	    conn_id := 123, 
	    port_number := 502,
	    timeout := T#2s,
	    buffer_db_any := "modbus_tcp_buffer",  
	    buffer_variant := "modbus_tcp_buffer", 
	    mb := #mb);
	
	// - interface:      Ethernet port to be used The const. is found
	//                   inside the "hardware configuration".              
	// - conn_id:        A unique id for each tcp connectin in the plc-program.
	// - tcp_port:       502 is the standard modbus tcp port.
	// - timeout:
	// - buffer_db_any:  A db with standard access consisting a array of 125 words.
	// - buffer_variant: Input the same variable as above.
	// - udt_mb:         The udt is the link the controller to its belonging queries.
	
	
	#device_start_example(
	    unit := 1, // device address. For tcp devices unit can usually be set to "1".                                  
	    mb := #mb);
	
	// Note that a device block can be used for both tcp and rtu. This of
	// course require that the device has interface or a interface extension,
	// for both for Ethernet and RS-485. (Or a RS-485 alternativ)
	
	// If a tcp-rtu-gateway is used, then more device blocks can be placed here
	// as in the rtu example.
	
	
	// Read holding register 456 from device with unit address 123. This is an
	// example of that a query does not necessarily need to be inside a device
	// block as obove, however making reusable device blocks is good practice.
	"mb_query"(unit := 123,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 456,
	           d_len := #mb.c.auto_len,
	           data := #resault_data_1,
	           mb := #mb);
	
END_FUNCTION_BLOCK

DATA_BLOCK "modbus_tcp_start_example_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"modbus_tcp_start_example"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "modbus_rtu_start_example_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"modbus_rtu_start_example"

BEGIN

END_DATA_BLOCK

ORGANIZATION_BLOCK "rtu_ob"
TITLE = "Main Program Sweep (Cycle)"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	
	// Open the block to see the example.
	"modbus_rtu_start_example_DB"();
	
END_ORGANIZATION_BLOCK

FUNCTION "readme" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	(*
	The software is written for both S7-1200 and S7-1500 series, 
	but unfortunately not for S7-300 and S7-400 series. 
	
	If the library is only used for rtu then all blocks related 
	to tcp should be removed to save memory. Equally all rtu 
	blocks should be removed if the libraryis only used for tcp.
	
	The library extand on MB_MASTER and MB_CLIENT that comes 
	along with TIA portal. The library doesn't includes any 
	functinaly for modbus slave or modbus server. Take a look at 
	MB_SLAVE or MB_SERVER, which is also included in TIA-portal, 
	for those functionalities.
	
	
END_FUNCTION

ORGANIZATION_BLOCK "tcp_ob"
TITLE = "Main Program Sweep (Cycle)"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	
	// Open the block to see the example.
	"modbus_tcp_start_example_DB"();
	
END_ORGANIZATION_BLOCK

FUNCTION_BLOCK "example_sm"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt := 1;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      query_1 : Word;
      query_2 : Word;
      query_3 : Word;
      state : SInt;
   END_VAR


BEGIN
	// This is an advanced example which most users don't need to
	// worry about. Read "modbus_device_start_example" before
	// reading this example.
	// 
	// If there is a need of forcing some queries to be executed
	// in a given order, then the example bellow should be followed.
	
	CASE #state OF
	    0:
	        "mb_query"(unit := #unit,
	                   fc := #mb.fc.write_holding_reg,
	                   d_addr := 123,
	                   d_len := #mb.c.auto_len,
	                   data := #query_1,
	                   mb := #mb);
	        #state := #state + BOOL_TO_SINT(#mb.query_above.done);
	        // "#mb.query_above.done" is true if the query above
	        // in the code just finnished a sucessfull query.
	        // There is also "#mb.query_above.error" to check if
	        // the query above resualted in an error.    
	    1:
	        "mb_query"(unit := #unit,
	                   fc := #mb.fc.write_holding_reg,
	                   d_addr := 456,
	                   d_len := #mb.c.auto_len,
	                   data := #query_2,
	                   mb := #mb);
	        #state := #state + BOOL_TO_SINT(#mb.query_above.done);
	    2:
	        "mb_query"(unit := #unit,
	                   fc := #mb.fc.read_holding_reg,
	                   d_addr := 789,
	                   d_len := #mb.c.auto_len,
	                   data := #query_3,
	                   mb := #mb);
	        #state := SEL(G := #mb.query_above.done, IN0 := #state, IN1 := 0);
	END_CASE;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "example_siemens_PAC3200"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      device_udt : "udt_mb_device";
      current : Struct
         a : Real;   // unit: A
         b : Real;   // unit: A
         c : Real;   // unit: A
      END_STRUCT;
      common : Struct
         frequency : Real;   // unit: hz
         avg_voltage_Vph_n : Real;   // unit: V
         avg_voltage_Vph_ph : Real;   // unit: V
         avg_current : Real;   // unit: A
         total_apparent_power : Real;   // unit: VA
         total_active_power : Real;   // unit: W
      END_STRUCT;
   END_VAR


BEGIN
	// - Siemens - PAC3200
	// - http://w3.siemens.com.br/buildingtechnologies/br/documents/manual-sentron-pac3200.pdf
	//   3.9.3, page 40
	// - Example code, no test with equipment done.
	
	"mb_device_header"(device := #device_udt, mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 13,
	           d_len := #mb.c.auto_len,
	           data := #current,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 55,
	           d_len := #mb.c.auto_len,
	           data := #common,
	           mb := #mb);
	
	"mb_device_footer"(device := #device_udt, mb := #mb);
END_FUNCTION_BLOCK

