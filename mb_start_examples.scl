FUNCTION_BLOCK "start_example_device_block"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt := 1;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      common : "udt_mb_common";
      resault_data_query_1 : Struct
         word_1 : Word;
         word_2 : Word;
      END_STRUCT;
      resault_data_query_2 : Array[1..2] of Word;
      conditon_of_exec_query_4 : Bool;
      data_query_3 : Word;
      data_query_4 : Word;
      data_query_5 : Word;
   END_VAR


BEGIN
	// Start example for a device blocks. A device block is a FB  that is
	// written for one specific modbus device. It maps registers of the
	// device to variables inside the FB.
	
	
	// Every device block should start with a device header as showed
	// bellow. Just ignore it for now, since it isn't a hundred percent
	// necessary to make the library work, though it give many advantages.
	// The benefit of the header is described at the bottom of this block.
	"mb_device_header"(common := #common, mb := #mb);
	
	
	// Modbus documentation addressing:
	// ---------------------------------
	// According to the Modicon convention, modbus address 40001 is holding
	// register #1. Register #1 is accessed with zero in a modbus telegram.
	// This design has led to confusion over the years, and modbus documentation
	// has unfortunately not been standardized. See details described bellow:
	// 
	//   - The Modicon convention:
	//     The manual for a given device provide a address that "embedded"
	//     register type. Example: 40005 is holding register with address 4.
	//     30008 is input register with address 7. This is how mb_client and
	//     mb_master in TIA-portal is implemented.
	//     
	//   - JBUS: (Direct addressing)
	//     The manual provide the data addr. that corresponds directly to
	//     the value transferred inside the modbus telegram. The function code
	//     determine what kind of register that should be accessed. Eg. "3"
	//     (read) holding register.
	//     
	//  -  Register address: (Offset of one):
	//     The register address is given in the manual. This means that
	//     there is a offset of one. (Reg_addr = telegram_value + 1)
	//
	// The library support JBUS and the Modicon convention. The first example 
	// describe JBUS while there is a Modicon convention example further down.
	// Other way of addressing has to be calculated manually.
	
	
	// JBUS addressing (direct addressing).
	// ------------------------------------------
	"mb_query"(unit := #unit,
	           fc := #mb.c.read.holding_reg,
	           d_addr := 123,
	           d_len := #mb.c.auto_len,
	           data := #resault_data_query_1,
	           mb := #mb);
	//
	// A standard modbus telegram
	// .------.------.------------.------------.--  ..  ..  -- --.------------.
	// | unit |  fc  |   d_addr   |   d_len    |      data       |    CRC     |
	// '------'------'------------'------------'-- --  ..  ..  --'------------'
	//
	// --- unit:
	// Device address. 1-247 (RTU station address)
	//
	// --- fc:
	// Modbus function code, supported codes: 1, 2, 3, 4, 5, 6, 15 and 16. Start
	// typing "#mb.c." and the auto complete list will show all available function
	// codes. 
	//
	// --- d_addr:
	// Data addr, the actual value that will be sent in the modbus telegram.
	// Eg. to read holding address 123, you simply pass 123 to d_addr and
	// "#mb.c.read.holding_reg" (3) to the fc-parameter. 40001 should NOT be
	// added to 123.
	//
	// --- d_len:
	// Data length. By passing zero (#mb.c.auto_len) to the parameter the
	// library will calculate this parameter automatically. In the example above
	// "data" consist of two words, so the value of d_len inside the telegram
	// will also be two. By entering d_len manually the library will run a bit 
	// faster.
	//
	// --- data:
	// Data ptr. In the case of a read query the content of the modbus telegram
	// will be written in to "data". Equally the content of "data" will be sent
	// to a modbus device in the case of a write query. The parameter is not
	// limited to words, but can contain any complex data structure with all
	// kind of data types. Eg. real, bool, bytes, arrays, etc.
	// Though, Three criterion most to be followed:
	// 1. The datatype should match the datatype of the registers in the device.
	//    For some devices the received data needs a "swap" or a "swap_word" after.    
	// 2. Only whole registers. (Bytes and bools should add up to 16 bits)
	// 3. The modbus protocol limit each query to a maximum of 123 words.
	//    (Sometimes up to 125 words)
	//
	// --- mb:
	// The udt that bind everything together. 
	
	
	// The Modicon convention addressing:
	// -------------------------------------
	"mb_query"(unit := #unit,
	           fc := #mb.c.mode.read,
	           d_addr := 40005,
	           d_len := #mb.c.auto_len,
	           data := #data_query_4,
	           mb := #mb);
	// The parameters: unit, d_len, data and mb, work the same way as in the
	// previous example. To use the Modicon convention, one of the fc-constants
	// bellow should be used:
	//   - #mb.c.mode.read           -> mb function code: 1, 2, 3 and 4  
	//   - #mb.c.mode.write          -> mb function code: 15 and 16      
	//   - #mb.c.mode.write_single   -> mb function code: 5 and 6        
	// 
	// When the modicon convention is used, the function code is "embedded" in
	// to d_addr. Eg. query 40005 will actually query holding register with
	// data address (offset) 4. Keep in mind that modes for mb_master and
	// mb_cleint are shifted, e.g. 200 corresponds to mode 0.
	
	
	// Other query examples:
	// ----------------------------
	// Similar query as above, except two input register are read. Any number
	// of queries can be added, the library will take care of executing them,
	// one by one.
	"mb_query"(unit := #unit,
	           fc := #mb.c.read.input_reg,
	           d_addr := 1234,
	           d_len := #mb.c.auto_len,
	           data := #data_query_3,
	           mb := #mb);
	
	
	// A write query executed with function code "6" (write.single_holding_reg)
	"mb_query"(unit := #unit,
	           fc := #mb.c.write.single_holding_reg,
	           d_addr := 42,
	           d_len := 1,
	           data := #data_query_5,
	           mb := #mb);
	// Some (old) modbus devices doesn't support modbus function code "16"
	// "write.holding_reg". In that case function code number "6" need to
	// be used ("mb.c.write.single_holding_reg"). Look up supported function
	// codes in the manual for the modbus device.
	
	
	// A query that has a condition for execution.
	IF #conditon_of_exec_query_4 THEN
	    "mb_query"(unit := #unit,
	               fc := #mb.c.write.holding_reg,
	               d_addr := 12345,
	               d_len := #mb.c.auto_len,
	               data := #data_query_4,
	               mb := #mb);
	END_IF;
	// When there is a plc-scan where the number of queries changes, the
	// library gets a little "hiccup". If the if-statement changes rapidly,
	// then the example above won't work, and it will also interfere with
	// other queries bellow. Look at "special_example_conditon" FB for how
	// it should be done. However If the condition for the query change
	// only once a while, then the example above will work fine.
	
	
	// Header and footer
	// -----------------------------------
	// As mention at the top the mb_device_header is not a hundred percent
	// necessary, so isn't the mb_device_footer. However if the "footer"
	// is implemented then the "header" has to be implement as well, else
	// the library will not work. No query should go before the "header"
	// or after the "footer".
	"mb_device_footer"(common := #common, mb := #mb);
	// Bellow are the benefits of using the device header and the footer:
	//  - The logging capacities: Inside the device-udt there is logging of
	//    successfully and failed queries, which is helpful
	//    for debugging. Look inside the udt, "#common.log. ..."
	//  - "#common.out.error" a common error flag that is set if any of the
	//    intermediate queries between mb_device_footer and mb_device_header
	//    gives a error. This flag is intended for use with HMI. The pulse
	//    length of the flag can be configured with
	//    "#common.conf.errror_flag_puls_length".
	//  - "#common.out.communication_error" a error flag that will be set after
	//    number of repeating timeout of the intermediate queries. Intended
	//    to reset values when communication problems occur. The number of
	//    repeating timeout before the flag is set can be configured with
	//    "#common.conf.max_repeating_timeouts".
	//  - Only one query for each device is allowed to be executed for
	//    every loop. This is to avoid devices with many queries to occupy
	//    the bus for long periods of time.
	//  - Prevent the impact of setting if-condition around queries. The
	//    "hiccup" effect mentioned above.
	
	
	// For this example values are set to zero if communication problems accrue.
	IF #common.out.communication_error THEN
	    #resault_data_query_1.word_1 := 0;
	    #resault_data_query_1.word_2 := 0;
	    
	    #resault_data_query_2[1] := 0;
	    #resault_data_query_2[2] := 0;
	    
	    #data_query_3 := 0;
	END_IF;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "example_novus_tht"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt;
   END_VAR

   VAR_OUTPUT 
      temperature : Int;
      humidity : Int;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      common : "udt_mb_common";
      serial_number : DWord;
      raw_values { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : Struct
         temp { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : Int;
         hum { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : Int;
      END_STRUCT;
   END_VAR


BEGIN
	// - Novus - RHT (Temperature transmitter)
	// - http://www.novusautomation.com/downloads/Arquivos/v10x_b_manual_rht_wm-dm-p10_485_lcd_%20english.pdf
	// - Example code, no test with real equipment done.
	
	"mb_device_header"(common := #common, mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.c.read.holding_reg,
	           d_addr := 7,
	           d_len := #mb.c.auto_len,
	           data := #raw_values,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.c.read.holding_reg,
	           d_addr := 0,
	           d_len := #mb.c.auto_len,
	           data := #serial_number,
	           mb := #mb);
	
	"mb_device_footer"(common := #common, mb := #mb);
	
	IF #common.out.communication_error THEN
	    #serial_number := 0;
	    #raw_values.temp := 0;
	    #raw_values.hum := 0;
	END_IF;
	
	#temperature := #raw_values.temp / 10;
	#humidity := #raw_values.hum / 10;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "example_abb_aquaMaster_3"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      common : "udt_mb_common";
      flow : Real;
      pressure : Real;
      totaliser : Struct
         fwd : DWord;
         rev : DWord;
         net : DWord;
      END_STRUCT;
   END_VAR


BEGIN
	// - ABB - AquaMaster 3 - Electromagnetic flowmeter
	// - COI/FET2XX/MOD/TBL–EN
	// - https://library.e.abb.com/public/91eead459bb0d349c12577fc0033d2b5/COI_FET2XX_MOD_TBL-EN.pdf
	// - Example code, no test with real equipment done.
	
	"mb_device_header"(common := #common, mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.c.read.input_reg,
	           d_addr := 5017,
	           d_len := 2,
	           data := #flow,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.c.read.input_reg,
	           d_addr := 5025,
	           d_len := 2,
	           data := #pressure,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.c.read.holding_reg,
	           d_addr := 12003,
	           d_len := #mb.c.auto_len,
	           data := #totaliser,
	           mb := #mb);
	
	"mb_device_footer"(common := #common, mb := #mb);
	
	IF #common.out.communication_error THEN
	    #flow := 0;
	    #pressure := 0;
	END_IF;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "start_example_mb_rtu"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      mb : "udt_mb";
      mb_master_ctrl : "mb_master_ctrl";
      device_start_example_device1 : "start_example_device_block";
      device_start_example_device2 : "start_example_device_block";
      device_start_example_device3 : "start_example_device_block";
      example_novus_tht_device1 : "example_novus_tht";
      example_novus_tht_device2 : "example_novus_tht";
      example_abb_aquaMaster_3_device1 : "example_abb_aquaMaster_3";
      example_abb_aquaMaster_3_device2 : "example_abb_aquaMaster_3";
      resault_data_1 : Word;
   END_VAR


BEGIN
	// hardware_id:     Setup the rtu-line in the hardware configurator
	// baud:            bits per secound.	
	// timeout:         Timeout for each query.
	// mb:              A udt that is the link between the controller and it's
	//                  belonging queries inside the device block bellow.                 
	#mb_master_ctrl(hardware_id := "Local~CB_1241_(RS485)", 
	    		baud := 9600, 	    
	    		timeout := T#500ms, 
	    		mb := #mb );
	
	                 
	// In this rtu example there are 7 devices (units) connected to the
	// modbus rtu bus. Each instance of the blocks bellow represent one
	// device on the bus. A "device block" has to be created for each
	// spesific device. Becouse the library makes it possible to avoid
	// global states, device bloks can be reused for all simular devices.
	// 
	// In this way is very easy to reuse
	// code, once there has been created a "device block" for one device.
	
	// Open the start example to see how a device block works.
	// ( unit => device-address ) 
	#device_start_example_device1(unit := 1, mb := #mb);
	#device_start_example_device2(unit := 2, mb := #mb);
	#device_start_example_device3(unit := 3, mb := #mb);
	
	// Two "novus THT" temperatur transmitters.
	#example_novus_tht_device1(unit := 4, mb := #mb);
	#example_novus_tht_device2(unit := 5, mb := #mb);
	
	// Two abb aqua master 3 devices.
	#example_abb_aquaMaster_3_device1(unit := 6, mb := #mb);
	#example_abb_aquaMaster_3_device2(unit := 7, mb := #mb);
	
	// Keep in mind that a device block can be used both for modbus rtu
	// and tcp. This is specially useful if a tcp-rtu-gateway is used.
	// The same program could be used, just swap the rtu controller, with
	// the tcp controller.
	
	
	// Read holding register 456 from device with unit address 123. This
	// is an example showing that a query does not necessarily need to be
	// inside a device block as obove, however making reusable device
	// blocks is good practice.
	"mb_query"(unit := 123,
	           fc := #mb.c.read.holding_reg,
	           d_addr := 456,
	           d_len := #mb.c.auto_len,
	           data := #resault_data_1,
	           mb := #mb);
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "start_example_mb_tcp"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      mb : "udt_mb";
      mb_client_ctrl : "mb_client_ctrl";
      device_start_example : "start_example_device_block";
      resault_data_1 : Word;
      log : Array[1..20] of Word;
   END_VAR


BEGIN
	// interface:  Profinet interface, Can be found inside the
	//             "hardware configuration".
	// conn_id:    A unique id for each tcp connectin in the plc-program.
	// ip_addr:    The ip-address of the server.
	// tcp_port:   TCP-port. 502 is the default port. UDP isn't available.
	// timeout:    
	// mb:         A udt that link the queries to there belonging controller.
	#mb_client_ctrl.ip_addr[1] := 192;
	#mb_client_ctrl.ip_addr[2] := 168;
	#mb_client_ctrl.ip_addr[3] := 1;
	#mb_client_ctrl.ip_addr[4] := 2;
	#mb_client_ctrl(
	    interface := "Local~PROFINET_interface_1",
	    conn_id := 123, 
	    tcp_port := 502,
	    timeout := T#1s,
	    mb := #mb);
	
	#device_start_example(unit := 1,   // Device address. For tcp/ip devices
	                                   // unit can usually be set to "1".
	                      mb := #mb);  // Same udt as for mb_client_ctrl above.
	// Note that a device block can be used for both tcp and rtu. This of course
	// require that the device has the hardware for both for TCP (Ethernet) and
	// for RTU (RS-485, RS-422 and RS-232).
	
	// Read holding register 1234 from device with unit address 123. This is an
	// example showing that a query can be independent from a device block.
	// However all the features of the device header and footer won't then be
	// available.
	"mb_query"(unit := 123,
	           fc := #mb.c.read.holding_reg,
	           d_addr := 1234,
	           d_len := #mb.c.auto_len,
	           data := #resault_data_1,
	           mb := #mb);
	
	"mb_log_word"(in := #mb.stat.status, log := #log);
	// This is only for debugging. If a strange error occurred then take a look
	// a the log variable. The status coodes is decribed in tia-portal help
	// journal. Look up MB_CLIENT, TCON, TSEND and TDISCON, to find the meaning
	// of the error codes.
	
END_FUNCTION_BLOCK

DATA_BLOCK "start_example_mb_tcp_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"start_example_mb_tcp"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "start_example_mb_rtu_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"start_example_mb_rtu"

BEGIN

END_DATA_BLOCK

ORGANIZATION_BLOCK "rtu_ob"
TITLE = "Main Program Sweep (Cycle)"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	// Program cycle OB
	
	// Open the block to see the example.
	"start_example_mb_rtu_DB"();
	
END_ORGANIZATION_BLOCK

FUNCTION "README" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	(*
	The software is written for both S7-1200 and S7-1500 series, 
	but is unfortunately not supported for S7-300 and S7-400 series. 
	
	If the library is only used for rtu then all blocks related 
	to tcp can be removed to save memory. Equally all rtu 
	blocks can be removed if the library is only used for tcp.
	Alternatively can blocks that are not used, be moved to the
	library.
	
	If there is a lot of errors during import, then make sure to
	import the udt's, and compile again. There should be one error 
	if the import is successfully. This is due to the missing rtu 
	hardware configuration.
	
	OB-call: 
	The function blocks should be called from a Program cycle OB.
	Advaced user may use Interval interupt OB, but doing so can 
	cause serious problems if the cycle time is to short. All 
	query blocks connected to a controller has to be called in the 
	same order for each scan, implicate they have to be called from 
	the same OB.
	
	The library extend on MB_MASTER and MB_CLIENT that comes 
	along with TIA portal. The library doesn't includes any 
	functionality for modbus slave or modbus server. Take a look 
	at MB_SLAVE or MB_SERVER, which is included in TIA-portal, 
	for those functionalities.
	
	To understand the examples it's recommended to acquire some 
	basic knowlage about modbus. More readings at the links bellow:
	 - http://www.csimn.com/CSI_pages/Modbus101.html
	 - http://www.simplymodbus.ca/FAQ.htm
	 - http://www.modbus.org/specs.php
	 
	Resurs requirements (memory):
	--------------------------                    
	SYSTEM BLOCKS USED:     Load memory     Work memory                    
	serialize:                   3.2 kB         0.71 kB                          
	deserialize:                 3.2 kB         0.71 kB            
	mb_comm_load:                4.5 kB         1.10 kB (only RTU)
	mb_master:                   7.1 kB         3.57 kB (only RTU)
	mb_client:                  33.0 kB         17.0 kB (only TCP)
	
	The library itself (about): 90.0 kB          4.0 kB 
	
	The total memory requirements will strongly dependent on the number 
	of queries and the number for devices. For a typical rtu application 
	with four devices it most be expected about 15 kB of work memory 
	will be used. For similar tcp application described above it must be 
	expected a scan time on 15 ms.
	
	Total avab. mem. for a: 
	                 1212C:      1.0 MB         75.0 kB 
	                 1214C:      4.0 MB        100.0 kB
	*)
END_FUNCTION

ORGANIZATION_BLOCK "tcp_ob"
TITLE = "Main Program Sweep (Cycle)"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	// Program cycle OB
	
	// Open the block to see the example.
	"start_example_mb_tcp_DB"();
	
END_ORGANIZATION_BLOCK

FUNCTION_BLOCK "example_siemens_PAC3200"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      common : "udt_mb_common";
      current : Array[1..3] of Real;
      misc : Struct
         frequency : Real;   // unit: hz
         avg_voltage_Vph_n : Real;   // unit: V
         avg_voltage_Vph_ph : Real;   // unit: V
         avg_current : Real;   // unit: A
         total_apparent_power : Real;   // unit: VA
         total_active_power : Real;   // unit: W
      END_STRUCT;
   END_VAR


BEGIN
	// - Siemens - PAC3200
	// - http://w3.siemens.com.br/buildingtechnologies/br/documents/manual-sentron-pac3200.pdf
	//   3.9.3, page 40
	// - Example code, no test with real equipment done.
	
	"mb_device_header"(common := #common, mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.c.read.holding_reg,
	           d_addr := 13,
	           d_len := #mb.c.auto_len,
	           data := #current,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.c.read.holding_reg,
	           d_addr := 55,
	           d_len := #mb.c.auto_len,
	           data := #misc,
	           mb := #mb);
	
	"mb_device_footer"(common := #common, mb := #mb);
	
	IF #common.out.communication_error THEN
	    UFILL_BLK(IN := 0, COUNT := 3, OUT => #current[1]);
	END_IF;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "special_example_2_conditon"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      condition_for_exec_query_1 : Bool;
      resault_data_query_1 : Word;
      condition_for_exec_query_2 : Bool;
      resault_data_query_2 : Word;
      R_TRIG_Instance {OriginalPartName := 'R_TRIG_1200'; LibVersion := '1.0'} : R_TRIG;
      start : Bool;
   END_VAR


BEGIN
	// If a condition is require for a query to be executed and the condition
	// changes state rapedly. Then the example bellow should be followed.
	// If the condition only changes once a while, then the example bellow
	// can be ignored.
	
	"mb_query"(unit := 123,
	           fc := SEL(G := #condition_for_exec_query_1,
	                     IN0 := #mb.c.skip_query,
	                     IN1 := #mb.c.write.holding_reg),
	           d_addr := 12345,
	           d_len := #mb.c.auto_len,
	           data := #resault_data_query_1,
	           mb := #mb);
	
	// -------------------------------------------------------------
	
	// To make sure that a query is executed only once the exmple 
	// bellow can be used.
	#R_TRIG_Instance(CLK := #condition_for_exec_query_2);
	IF #R_TRIG_Instance.Q THEN
	    #start := true;
	END_IF;
	
	"mb_query"(unit := 123,
	           fc := SEL(G := #start,
	                     IN0 := #mb.c.skip_query,
	                     IN1 := #mb.c.write.holding_reg),
	           d_addr := 12345,
	           d_len := 1,
	           data := #resault_data_query_2,
	           mb := #mb);
	
	IF #mb.stat.query_above AND #mb.stat.done THEN
	    #start := false;
	END_IF;
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "special_example_1_state_machine"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt := 1;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      query_1 : Word;
      query_2 : Word;
      query_3 : Word;
      state : SInt;
   END_VAR


BEGIN
	// This is an advanced example which most users don't need to
	// worry about. Read "modbus_device_start_example" before
	// reading this example.
	// 
	// If there is a need of forcing some queries to be executed
	// in a given order, then the example bellow should be followed.
	
	CASE #state OF
	    0:
	        "mb_query"(unit := #unit,
	                   fc := #mb.c.write.holding_reg,
	                   d_addr := 123,
	                   d_len := #mb.c.auto_len,
	                   data := #query_1,
	                   mb := #mb);
	        #state := #state + BOOL_TO_SINT(#mb.stat.query_above AND #mb.stat.done);
	        // "#mb.stat.query_above" is true if the query above
	        // in the code just finnished a query. (with or without error)        
	    1:
	        "mb_query"(unit := #unit,
	                   fc := #mb.c.write.holding_reg,
	                   d_addr := 456,
	                   d_len := #mb.c.auto_len,
	                   data := #query_2,
	                   mb := #mb);
	        #state := #state + BOOL_TO_SINT(#mb.stat.query_above AND #mb.stat.done);
	    2:
	        "mb_query"(unit := #unit,
	                   fc := #mb.c.read.holding_reg,
	                   d_addr := 789,
	                   d_len := #mb.c.auto_len,
	                   data := #query_3,
	                   mb := #mb);
	        #state := SEL(G := #mb.stat.query_above AND #mb.stat.done, IN0 := #state, IN1 := 0);
	END_CASE;
	
END_FUNCTION_BLOCK

