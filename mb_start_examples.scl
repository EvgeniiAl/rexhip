FUNCTION_BLOCK "example_abb_aquaMaster_3"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      device_udt : "udt_mb_device";
      flow : Real;
      pressure : Real;
      totaliser : Struct
         fwd : DWord;
         rev : DWord;
         net : DWord;
      END_STRUCT;
   END_VAR


BEGIN
	// - ABB - AquaMaster 3 - Electromagnetic flowmeter
	// - COI/FET2XX/MOD/TBL–EN
	// - https://library.e.abb.com/public/91eead459bb0d349c12577fc0033d2b5/COI_FET2XX_MOD_TBL-EN.pdf
	// - Example code, no test with equipment done.
	
	"mb_device_header"(device := #device_udt, mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_input_reg,
	           d_addr := 5017,
	           d_len := 2,
	           data := #flow,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_input_reg,
	           d_addr := 5025,
	           d_len := 2,
	           data := #pressure,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 12003,
	           d_len := #mb.c.auto_len,
	           data := #totaliser,
	           mb := #mb);
	
	"mb_device_footer"(device := #device_udt, mb := #mb);
	
	IF #device_udt.qComError THEN
	    #flow := 0;
	    #pressure := 0;
	END_IF;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "modbus_device_start_example"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt := 1;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      device_udt : "udt_mb_device";
      resault_data_query_1 : Struct
         word_1 : Word;
         word_2 : Word;
      END_STRUCT;
      resault_data_query_2 : Array[1..2] of Word;
      conditon_of_exec_query_4 : Bool;
      data_query_3 : Word;
      data_query_4 : Word;
      data_query_5 : Word;
   END_VAR


BEGIN
	// Start example for a device blocks. A device block is a FB  that is
	// written for one specific modbus device. It maps registers of the
	// device to variables inside the FB. Similar to a gsd-file for profibus.
	
	// Just ignore mb_device_header for now. It isn't a hundred percent
	// necessary, but give many advantages to implement it.
	"mb_device_header"(device := #device_udt, mb := #mb);
	
	
	// According to the Modicon convention, modbus address 40001 is holding
	// register #1. Register #1 is data address zero, (offset zero).
	//
	// This design has led to confusion over the years, and modbus documentation
	// has unfortunately not been standardized. Regardless it's anyway the data
	// addresses that will be transferred in the modbus telegram. 
	// 
	//   - The Modicon convention:
	//     The documentation give a address that "embedded" register type.
	//     Example: 40005 is holding register with address 4. 30008 is
	//     input register with address 7. This is how mb_client and
	//     mb_master in TIA-portal is implemented.
	//     
	//   - JBUS 
	//     The documentation give the data addr. that corresponds directly to
	//     the value transferred inside the modbus telegram. The function code
	//     determine what kind of register that should be accessed. Eg. "3"
	//     (read) holding register.
	//     
	//  -  Register address (Offset of one):
	//     The register address is given in the documentation. This means that
	//     there is a offset of one. (Data_addr = Reg_addr - 1)
	//
	// The library support the Modicon convention and JBUS. The first example 
	// describe JBUS while there is a Modicon convention example further down.
	
	
	// JBUS addressing.
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 123,
	           d_len := #mb.c.auto_len,
	           data := #resault_data_query_1,
	           mb := #mb);
	//
	// A modbus telegram
	// .------.------.------------.------------.--  ..  ..  -- --.------------.
	// | unit |  fc  |   d_addr   |   d_len    |      data       |    CRC     |
	// '------'------'------------'------------'-- --  ..  ..  --'------------'
	//
	// --- unit:
	// Device address. 1-247 (RTU station address)
	//
	// --- fc:
	// Modbus function code, supported codes: 1, 2, 3, 4, 5, 6, 15 and 16. Start
	// typing "#mb.fc." and the auto complete list will show all available function
	// codes. 
	//
	// --- d_addr:
	// Data addr, the actual value inside the modbus telegram, (the offset).
	// Eg. to read holding address 123, you simply pass 123 to d_addr and 
	// "#mb.fc.read_holding_reg" (3) to fc. 40001 should NOT be added to 123.
	//
	// --- d_len:
	// Data length. By passing zero (#mb.c.auto_len) to the parameter the
	// library will calculate this parameter automatically. In the example above
	// "data" consist of two words, so the value of d_len inside the telegram
	// will also be two. By entering d_len manually the library will run a bit 
	// faster.
	//
	// --- data:
	// Data ptr. In the case of a read query the content of the modbus telegram
	// will be written in to the variable connected to data-param. Equally the
	// content will be sent to a modbus device in the case of a write query.
	// The parameter is not limited to words, but can contain any complex data
	// structure with all kind of data types. Likes real, bool, bytes, arrays, etc.
	// Three criterion has to be followed:
	// 1. The datatype should match the datatype of the registers in the device.
	//    For some devices the received data needs a "swap" or a "swap_word" after.    
	// 2. Only whole registers. (Bytes and bools should add up to 16 bits)
	// 3. The modbus protocol limit each query to a maximum of 123 words.
	//    (Sometimes up to 125 words)
	//
	// --- mb:
	// The udt that bind everything together. 
	
	
	// The Modicon convention addressing:
	"mb_query"(unit := #unit,
	           fc := #mb.fc.modicon_read,
	           d_addr := 40005,
	           d_len := #mb.c.auto_len,
	           data := #data_query_4,
	           mb := #mb);
	// The parameters: unit, d_len, data and mb, work the same way as in the
	// example above. To use the Modicon convention one of the fc-constants
	// bellow should be used:
	//   - #mb.fc.modicon_read           -> mb function code: 1, 2, 3 and 4  
	//   - #mb.fc.modicon_write          -> mb function code: 15 and 16      
	//   - #mb.fc.modicon_write_single   -> mb function code: 5 and 6        
	// 
	// When the modicon convention is used, the function code is "embedded" in
	// to d_addr. Eg. query 40005 will actually query holding register with
	// data address (offset) 4. Keep in mind that modes for mb_master and
	// mb_cleint are shifted, e.g. 200 corresponds to mode 0.
	
	
	// Similar query as above, except two input register are read.  Any number
	// of queries can be added, the library will take care of executing
	// them, one by one.
	"mb_query"(unit := #unit,
	           fc := #mb.fc.write_output_bits,
	           d_addr := 1234,
	           d_len := #mb.c.auto_len,
	           data := #data_query_3,
	           mb := #mb);
	
	
	// A write query executed with function code "6" (write_single_holding_reg)
	"mb_query"(unit := #unit,
	           fc := #mb.fc.write_single_holding_reg,
	           d_addr := 42,
	           d_len := 1,
	           data := #data_query_5,
	           mb := #mb);
	// Some (old) modbus devices doesn't support modbus function code "16"
	// "write_holding_reg". In that case function code number "6" need to
	// be used ("write_single_holding_reg"). Look up supported function
	// codes in the manual for the modbus device.
	
	
	// A query that has a condition for execution.
	IF #conditon_of_exec_query_4 THEN
	    "mb_query"(unit := #unit,
	               fc := #mb.fc.write_holding_reg,
	               d_addr := 12345,
	               d_len := #mb.c.auto_len,
	               data := #data_query_4,
	               mb := #mb);
	END_IF;
	// The condition for the queries above will work. However is recommended 
	// that the example bellow is followed if a condition for a queries is 
	// needed. Every time the number of queries is changed, the library is 
	// gets a little "hiccup". That can be avoided by doing as shown bellow. 
	// Though, the example above will mostly work perfectly fine.
	"mb_query"(unit := #unit,
	           fc := SEL(G := #conditon_of_exec_query_4,
	                     IN0 := #mb.fc.skip_query,
	                     IN1 := #mb.fc.write_holding_reg),
	           d_addr := 12345,
	           d_len := #mb.c.auto_len,
	           data := #data_query_4,
	           mb := #mb);
	// The "hiccup": If a result is waiting while the number of queries
	// is changing, then it may not be picked up, and the query has to
	// wait until all the other queries has been executed once more. If
	// the condition change rapidly on and off, then the first example
	// will not work and the second example need to be followed.
	
	
	// As mention at the top the mb_device_header is not a hundred percent
	// necessary, so isn't the mb_device_footer. However if the
	// "footer" is implemented then the "header" has to be implement. Else
	// the library will not work. No query should go before the "header"
	// or after the "footer".
	"mb_device_footer"(device := #device_udt,
	                   mb := #mb);
	// This are the benefits of using the device header and the footer FC's:
	//  - The logging capacities: Inside the device-udt there is logging of
	//    successfully and failed queries, which is helpful
	//    for debugging. Look at "#device_udt.log. ..."
	//  - "#device_udt.qError" a common error flag that is set if any of the
	//    intermediate queries between mb_device_footer and mb_device_header
	//    gives a error. This flag is intended for use with HMI. The puls
	//    length of the flag can be configured with
	//    "#device_udt.config.time_qErrror".
	//  - "#device_udt.qComError" a error flag that will be set after number
	//    of repeating timeout of the intermediate queries. Intended to reset
	//    values when communication problems occur. The number of repeating
	//    timeout before the flag is set can be configured with
	//    "#device_udt.config.max_qComError".
	//  - Only one query for each device is allowed to be executed for
	//    each loop. This is avoid devices with many queries to occupy
	//    the bus for long periods of time.
	//  - Prevent the impact of setting if-condition around queries. The
	//    "hiccup" effect mentioned above.
	
	
	// For this example values are set to zero if communication problems accrue.
	IF #device_udt.qComError THEN
	    #resault_data_query_1.word_1 := 0;
	    #resault_data_query_1.word_2 := 0;
	    
	    #resault_data_query_2[1] := 0;
	    #resault_data_query_2[2] := 0;
	END_IF;
	
END_FUNCTION_BLOCK

DATA_BLOCK "modbus_rtu_buffer"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
NON_RETAIN
   STRUCT 
      buffer : Array[0..125] of Word;
   END_STRUCT;


BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "example_novus_tht"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt;
   END_VAR

   VAR_OUTPUT 
      temperature : Int;
      humidity : Int;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      device_udt : "udt_mb_device";
      serial_number : DWord;
      raw_values { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : Struct
         temp { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : Int;
         hum { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : Int;
      END_STRUCT;
   END_VAR


BEGIN
	// - Novus - RHT (Temperature transmitter)
	// - http://www.novusautomation.com/downloads/Arquivos/v10x_b_manual_rht_wm-dm-p10_485_lcd_%20english.pdf
	// - Example code, no test with equipment done.
	
	"mb_device_header"(device := #device_udt, mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 7,
	           d_len := #mb.c.auto_len,
	           data := #raw_values,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 0,
	           d_len := #mb.c.auto_len,
	           data := #serial_number,
	           mb := #mb);
	
	"mb_device_footer"(device := #device_udt, mb := #mb);
	
	IF #device_udt.qComError THEN
	    #serial_number := 0;
	    #raw_values.temp := 0;
	    #raw_values.hum := 0;
	END_IF;
	
	#temperature := #raw_values.temp / 10;
	#humidity := #raw_values.hum / 10;
	
END_FUNCTION_BLOCK

DATA_BLOCK "modbus_tcp_buffer"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
NON_RETAIN
   STRUCT 
      buffer : Array[0..125] of Word;
   END_STRUCT;


BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "modbus_rtu_start_example"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      mb : "udt_mb";
      mb_master_controller : "mb_master_controller";
      device_start_example_device1 : "modbus_device_start_example";
      device_start_example_device2 : "modbus_device_start_example";
      device_start_example_device3 : "modbus_device_start_example";
      example_novus_tht_device1 : "example_novus_tht";
      example_novus_tht_device2 : "example_novus_tht";
      example_abb_aquaMaster_3_device1 : "example_abb_aquaMaster_3";
      example_abb_aquaMaster_3_device2 : "example_abb_aquaMaster_3";
      resault_data_1 : Word;
   END_VAR


BEGIN
	// hardware_id:     Setup the rtu-line in the hardware configurator
	// baud:            bps
	// parity:          Enable even parity. (Odd parity is not available)
	// timeout: 
	// buffer_db_any:   A db with standard access consisting a array of 125 words.
	// buffer_variant:  Input the same variable as to "buffer_db_any".
	// mb:              A udt that is the link between the controller and it's
	//                  belonging queries inside the device block bellow.                 
	#mb_master_controller(
	    hardware_id := "Local~CB_1241_(RS485)", 
	    baud := 9600, 
	    parity := true, 
	    timeout := T#500ms,   
	    buffer_db_any := "modbus_rtu_buffer", 
	    buffer_variant := "modbus_rtu_buffer", 
	    mb := #mb );
	
	                 
	// In this rtu example there are 7 devices (units) connected to the
	// modbus rtu bus. Each instance of the blocks bellow represent  one
	// device on the bus. A "device block" has to be created for each
	// spesific device. Becouse the library makes it possible to avoid
	// global states, device bloks can be reused for all simular devices.
	// 
	// In this way is very easy to reuse
	// code, once there has been created a "device block" for one device.
	
	// Open the start example to see how a device block works.
	// ( unit => device-address ) 
	#device_start_example_device1(unit := 1, mb := #mb);
	#device_start_example_device2(unit := 2, mb := #mb);
	#device_start_example_device3(unit := 3, mb := #mb);
	
	// Two "novus THT" temperatur transmitters.
	#example_novus_tht_device1(unit := 4, mb := #mb);
	#example_novus_tht_device2(unit := 5, mb := #mb);
	
	// Two abb aqua master 3 devices.
	#example_abb_aquaMaster_3_device1(unit := 6, mb := #mb);
	#example_abb_aquaMaster_3_device2(unit := 7, mb := #mb);
	
	// Keep in mind that a device block can be used both for modbus rtu
	// and tcp. This is specially useful if a tcp-rtu-gateway is used.
	// The same program could be used, just swap the rtu controller, with
	// the tcp controller.
	
	
	// Read holding register 456 from device with unit address 123. This
	// is an example showing that a query does not necessarily need to be
	// inside a device block as obove, however making reusable device
	// blocks is good practice.
	"mb_query"(unit := 123,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 456,
	           d_len := #mb.c.auto_len,
	           data := #resault_data_1,
	           mb := #mb);
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "modbus_tcp_start_example"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      mb : "udt_mb";
      mb_client_controller : "mb_client_controller";
      device_start_example : "modbus_device_start_example";
      resault_data_1 : Word;
      log : Array[1..20] of Word;
   END_VAR


BEGIN
	// interface:       Ethernet port to be used, the const. can be found inside
	//                  the "hardware configuration".
	// conn_id:         A unique id for each tcp connectin in the plc-program.
	// ip_addr:         The ip-address of the server, the client will communicate
	//                  with.
	// port_number:     TCP-port, 502 is the default port. UDP isn't available.
	// timeout:         Timeout.
	// buffer_db_any:   A db with standard access consisting a array of 125 words.
	// buffer_variant:  Input the same variable as to "buffer_db_any".
	// mb:              A udt that is the link between the controller and it's
	//                  belonging queries inside the device block bellow.
	#mb_client_controller.remote_ip[1] := 192;
	#mb_client_controller.remote_ip[2] := 168;
	#mb_client_controller.remote_ip[3] := 1;
	#mb_client_controller.remote_ip[4] := 2;
	#mb_client_controller(
	    interface := "Local~PROFINET_interface_1",
	    conn_id := 123, 
	    remote_port := 502,
	    timeout := T#2s,
	    buffer_db_any := "modbus_tcp_buffer",  
	    buffer_variant := "modbus_tcp_buffer", 
	    mb := #mb);
	
	#device_start_example(unit := 1,   // Device address. For tcp devices
	                                   // unit can usually be set to "1".
	                      mb := #mb);  // Same udt as above.
	// Note that a device block can be used for both tcp and rtu. This of course
	// require that the device has the hardware for both for TCP (Ethernet) and
	// for RTU (RS-485).
	
	// Read holding register 1234 from device with unit address 123. This is an
	// example showing that a query does not necessarily need to be inside a
	// device block as obove, however making reusable device blocks is good
	// practice. Also the logging capacities and timeout handeling will not be
	// utilized when done as bellow.
	"mb_query"(unit := 123,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 1234,
	           d_len := #mb.c.auto_len,
	           data := #resault_data_1,
	           mb := #mb);
	
	"mb_log_words"(in := #mb.status.status, log := #log);
	// This is only for debugging. If a strange error occurred then look in to the
	// log. The status coodes is decribed in tia-portal help journal. Look up
	// MB_CLIENT, TCON, TSEND and TDISCON.
	
END_FUNCTION_BLOCK

DATA_BLOCK "modbus_tcp_start_example_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"modbus_tcp_start_example"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "modbus_rtu_start_example_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"modbus_rtu_start_example"

BEGIN

END_DATA_BLOCK

ORGANIZATION_BLOCK "rtu_ob"
TITLE = "Main Program Sweep (Cycle)"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	// Program cycle OB
	
	// Open the block to see the example.
	"modbus_rtu_start_example_DB"();
	
END_ORGANIZATION_BLOCK

FUNCTION "README" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	(*
	The software is written for both S7-1200 and S7-1500 series, 
	but is unfortunately not supported for S7-300 and S7-400 series. 
	
	If the library is only used for rtu then all blocks related 
	to tcp can be removed to save memory. Equally all rtu 
	blocks can be removed if the library is only used for tcp.
	Alternatively can blocks that are not used, be moved to the
	library.
	
	If there is a lot of errors during import, then make sure to
	import the udt's, and compile again. There should be one error 
	if the import is successfully. This is due to the missing rtu 
	hardware configuration.
	
	OB-call: 
	The function blocks should be called from a Program cycle OB.
	Advaced user may use Interval interupt OB, but doing so can 
	cause serious problems if the cycle time is to short. All 
	query blocks connected to a controller has to be called in the 
	same order for each scan, implicate they have to be called from 
	the same OB.
	
	The library extend on MB_MASTER and MB_CLIENT that comes 
	along with TIA portal. The library doesn't includes any 
	functionality for modbus slave or modbus server. Take a look 
	at MB_SLAVE or MB_SERVER, which is included in TIA-portal, 
	for those functionalities.
	
	To understand the examples it's require to have some basic 
	knowlage about modbus. More readings about modbus at:
	 - http://www.csimn.com/CSI_pages/Modbus101.html
	 - http://www.simplymodbus.ca/FAQ.htm
	 - http://www.modbus.org/specs.php
	 
	Resurs requirements:
	--------------------------                    
	SYSTEM BLOCKS USED:     Load memory     Work memory                    
	serialize:                   3,2 kB         0,71 kB                          
	deserialize:                 3,2 kB         0,71 kB            
	mb_comm_load:                4,5 kB         1,10 kB (only RTU)
	mb_master:                   7,1 kB         3,57 kB (only RTU)
	mb_client:                  33,0 kB         17,0 kB (only TCP)
	
	The library itself:         86,2 kB          3,0 kB 
	
	The total memory requirements will strongly dependent on the number 
	of queries and the number for devices. For a typical rtu application 
	with four devices it most be expected about 15 kB of work memory 
	will be used. For similar tcp application described above it must be 
	expected a scan time on 15 ms.
	
	Total mem. for a 1212C:      1,0 MB         75,0 kB 
	                 1214C:      ?,? MB        100,0 kB
	   
END_FUNCTION

ORGANIZATION_BLOCK "tcp_ob"
TITLE = "Main Program Sweep (Cycle)"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	// Program cycle OB
	
	// Open the block to see the example.
	"modbus_tcp_start_example_DB"();
	
END_ORGANIZATION_BLOCK

FUNCTION_BLOCK "example_sm"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt := 1;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      query_1 : Word;
      query_2 : Word;
      query_3 : Word;
      state : SInt;
   END_VAR


BEGIN
	// This is an advanced example which most users don't need to
	// worry about. Read "modbus_device_start_example" before
	// reading this example.
	// 
	// If there is a need of forcing some queries to be executed
	// in a given order, then the example bellow should be followed.
	
	CASE #state OF
	    0:
	        "mb_query"(unit := #unit,
	                   fc := #mb.fc.write_holding_reg,
	                   d_addr := 123,
	                   d_len := #mb.c.auto_len,
	                   data := #query_1,
	                   mb := #mb);
	        #state := #state + BOOL_TO_SINT(#mb.query_above.done);
	        // "#mb.query_above.done" is true if the query above
	        // in the code just finnished a sucessfull query.
	        // There is also "#mb.query_above.error" to check if
	        // the query above resualted in an error.    
	    1:
	        "mb_query"(unit := #unit,
	                   fc := #mb.fc.write_holding_reg,
	                   d_addr := 456,
	                   d_len := #mb.c.auto_len,
	                   data := #query_2,
	                   mb := #mb);
	        #state := #state + BOOL_TO_SINT(#mb.query_above.done);
	    2:
	        "mb_query"(unit := #unit,
	                   fc := #mb.fc.read_holding_reg,
	                   d_addr := 789,
	                   d_len := #mb.c.auto_len,
	                   data := #query_3,
	                   mb := #mb);
	        #state := SEL(G := #mb.query_above.done, IN0 := #state, IN1 := 0);
	END_CASE;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "example_siemens_PAC3200"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt;
   END_VAR

   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR

   VAR 
      device_udt : "udt_mb_device";
      current : Struct
         a : Real;   // unit: A
         b : Real;   // unit: A
         c : Real;   // unit: A
      END_STRUCT;
      common : Struct
         frequency : Real;   // unit: hz
         avg_voltage_Vph_n : Real;   // unit: V
         avg_voltage_Vph_ph : Real;   // unit: V
         avg_current : Real;   // unit: A
         total_apparent_power : Real;   // unit: VA
         total_active_power : Real;   // unit: W
      END_STRUCT;
   END_VAR


BEGIN
	// - Siemens - PAC3200
	// - http://w3.siemens.com.br/buildingtechnologies/br/documents/manual-sentron-pac3200.pdf
	//   3.9.3, page 40
	// - Example code, no test with equipment done.
	
	"mb_device_header"(device := #device_udt, mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 13,
	           d_len := #mb.c.auto_len,
	           data := #current,
	           mb := #mb);
	
	"mb_query"(unit := #unit,
	           fc := #mb.fc.read_holding_reg,
	           d_addr := 55,
	           d_len := #mb.c.auto_len,
	           data := #common,
	           mb := #mb);
	
	"mb_device_footer"(device := #device_udt, mb := #mb);
	
END_FUNCTION_BLOCK

