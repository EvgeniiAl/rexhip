FUNCTION "mb_device_header" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_IN_OUT 
      device : "udt_mb_device";
      mb : "udt_mb";
   END_VAR


BEGIN
	#device.internal.range_start := #mb.run.qid_cnt + 1;
	#device.internal.tmp_recv_cnt := #mb.run.exec_cnt;
	
	IF #mb.q.qid >= #device.internal.range_start
	    AND #mb.q.qid <= #device.internal.range_end
	THEN
	    IF NOT #device.enable
	        OR NOT #mb.run.insert AND #mb.stat.timeout
	    THEN
	        #mb.run.insert := true;
	        #mb.q.qid := #device.internal.range_end + 1 ;
	    END_IF;
	END_IF;
END_FUNCTION

FUNCTION "mb_query" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      unit : USInt;   // Device addr. (0 to 247)
      "fc" : USInt;   // Function code: 1,2,3,4,5,6,15,16. (siemens mode shifted to 200 - 202)
      d_addr : UDInt;   // Addr. of register. (raw telegram value)
      d_len : UInt;   // 0=Auto detect, based on the array size of  data.
   END_VAR

   VAR_IN_OUT 
      data : Variant;   // word, int, uint or array of same datatypes.
      mb : "udt_mb";
   END_VAR

   VAR_TEMP 
      c : Int;
      e : Int;
      tmp_len : UInt;
      "word" : Word;
      "int" : Int;
      "uint" : UInt;
   END_VAR


BEGIN
	// Lightweight Modbus Abstraction Layer
	// Atuor:   Ola Bjørnli
	// Version: 0.1-alptha_7
	// License: GPLv2, MIT (pick the one of your need)
	// Web:     http://mb.sn7.no, http://github.com/olab84/sn7mb 
	
	#mb.query_above.done := false;
	#mb.query_above.err := false;
	#mb.query_above.insert := false;
	#mb.run.qid_cnt := #mb.run.qid_cnt + 1;
	if #mb.run.qid_cnt <> #mb.q.qid then return; end_if;
	
	#tmp_len := SEL(G := #d_len = 0, IN0 := #d_len,
	    IN1 := MAX(IN1 := 1, IN2 := UDINT_TO_UINT(CountOfElements(#data))));
	if #mb.run.insert then
	    case #fc of
	            (*    
	        1:  // Read output bits 
	            #mb.runtime.q.mode := 0;
	            #mb.runtime.q.data_addr := 1 + #register;
	        2:  // Read input bits
	            #mb.runtime.q.mode := 0;
	            #mb.runtime.q.data_addr := 10001 + #register;
	            *)
	        3:  // Read holding reg.
	            #mb.run.mode := 0;
	            #mb.run.data_addr := 400001 + #d_addr;
	        4:  // Read input word
	            #mb.run.mode := 0;
	            #mb.run.data_addr := 30001 + #d_addr;
	            (*
	        5:  // Writing a single output bit
	            #mb.runtime.q.mode := 1;
	            #mb.runtime.q.data_addr := 1 + #d_addr;
	            *)
	        6:  // Writing a single holding register
	            #mb.run.mode := 1;
	            #mb.run.data_addr := 400001 + #d_addr;
	            (*    
	        15: // Writing multiple output bits
	            #mb.runtime.q.mode := 2;
	            #mb.runtime.q.data_addr := 1 + #register;
	            *)
	        16: // Writing multiple holding registers
	            #mb.run.mode := 2;
	            #mb.run.data_addr := 400001 + #d_addr;
	            "d".a2 := "d".a2 + 1;
	        200..202 : // Siemens mode: 200-202 replace 0-2
	            #mb.run.mode := #fc - 200;
	            #mb.run.data_addr := #d_addr;
	    end_case;
	    #mb.q.unit := #unit;
	    #mb.q.fc := #fc;
	    #mb.q.d_addr := #d_addr;
	    #mb.q.d_len := #tmp_len;
	    if #mb.run.mode = 1 or #mb.run.mode = 2 then
	        "d".a3 := "d".a3 + 1;
	        for #c := 0 to UINT_TO_INT(#mb.q.d_len) - 1 do
	            "d".a4 := "d".a4 + 1;
	            if TypeOfElements(#data) = Word then
	                "d".a5 := "d".a5 + 1;
	            #e := MOVE_BLK_VARIANT(SRC := #data, SRC_INDEX := #c,
	                    COUNT := 1, DEST => #word, DEST_INDEX := 0);
	            elsif TypeOfElements(#data) = UInt then
	                #e := MOVE_BLK_VARIANT(SRC := #data, SRC_INDEX := #c,
	                    COUNT := 1, DEST => #uint, DEST_INDEX := 0);
	                #word := UINT_TO_WORD(#uint);
	            elsif TypeOfElements(#data) = Int then
	                #e := MOVE_BLK_VARIANT(SRC := #data, SRC_INDEX := #c,
	                    COUNT := 1, DEST => #int, DEST_INDEX := 0);
	                #word := INT_TO_WORD(#int);
	            end_if;
	            "d".a8 := #e;
	            "d".a6 := #c;
	            "d".a7 := #word;
	            POKE(area := 16#84, dbNumber := #mb.const.buffer,
	                 byteOffset := #c * 2,
	                 value := WORD_TO_BYTE(SHR(IN := #word, N := 8)));
	            POKE(area := 16#84, dbNumber := #mb.const.buffer,
	                 byteOffset := #c * 2 + 1,
	                 value := WORD_TO_BYTE(#word));
	        end_for;
	    end_if;
	    #mb.run.insert := false;
	    #mb.q.next := #mb.q.qid + 1;
	    #mb.query_above.insert := true;
	    
	elsif #mb.stat.done
	    and #mb.q.unit = #unit
	    and #mb.q.fc = #fc
	    and #mb.q.d_addr = #d_addr
	    and #mb.q.d_len = #tmp_len
	then
	    if #mb.run.mode = 0 then
	        for #c := 0 to UINT_TO_INT(#mb.q.d_len) - 1 do
	            #word := PEEK_WORD(area := 16#84,
	                dbNumber := #mb.const.buffer, byteOffset := #c * 2);
	            if TypeOfElements(#data) = Word then
	                #e := MOVE_BLK_VARIANT(SRC := #word,
	                    SRC_INDEX := 0, COUNT := 1, DEST => #data, DEST_INDEX := #c);
	            elsif TypeOfElements(#data) = UInt then
	                #e := MOVE_BLK_VARIANT(SRC := WORD_TO_UINT(#word),
	                    SRC_INDEX := 0, COUNT := 1, DEST => #data, DEST_INDEX := #c);
	            elsif TypeOfElements(#data) = Int then
	                #e := MOVE_BLK_VARIANT(SRC := WORD_TO_INT(#word),
	                    SRC_INDEX := 0, COUNT := 1, DEST => #data, DEST_INDEX := #c);
	            end_if;
	        end_for;
	    end_if;
	    #mb.query_above.done := true;
	    
	elsif #mb.stat.err then
	    #mb.query_above.err := true;
	end_if;
	
	if #mb.query_above.done or #mb.query_above.err then
	    #mb.run.insert := true;
	    #mb.run.exec_cnt := #mb.run.exec_cnt + 1;
	    #mb.q.qid := #mb.q.next;
	end_if;
END_FUNCTION

FUNCTION "mb_change_datatype" : Void
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_IN_OUT 
      in : Variant;
      out : Variant;
   END_VAR

   VAR_TEMP 
      tmp : Array[0..7] of Byte;
      pos : DInt;
      err : Int;
   END_VAR


BEGIN
	#err := Serialize(SRC_VARIABLE := #in, DEST_ARRAY => #tmp, POS := #pos);
	#pos := 0;
	#err := Deserialize(SRC_ARRAY := #tmp, DEST_VARIABLE => #out, POS := #pos);
	
END_FUNCTION

FUNCTION "mb_device_footer" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_IN_OUT 
      device : "udt_mb_device";
      mb : "udt_mb";
   END_VAR

   VAR_TEMP 
      _dtl {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;
      e : Int;
   END_VAR


BEGIN
	#device.internal.range_end := #mb.run.qid_cnt;
	
	IF #mb.run.exec_cnt - #device.internal.tmp_recv_cnt > 0 THEN
	    #e := RD_LOC_T(#_dtl);
	    IF #mb.stat.done THEN
	        #device.log.done_cnt := #device.log.done_cnt + 1;
	        #device.log.done_dtl := #_dtl;
	        #device.internal.err_cnt := 0;
	    ELSIF #mb.stat.err THEN
	        #device.log.err_cnt := #device.log.err_cnt + 1;
	        #device.log.err_dtl := #_dtl;
	        #device.log.err_status := #mb.stat.status;
	        #device.log.err_d_addr := #mb.q.d_addr ;
	        #device.internal.err_cnt := MIN(
	            IN1 := #device.internal.err_cnt + 1, IN2 := 255 );
	    END_IF;
	END_IF;
	
	#device.q.err := #device.enable AND (
	    #device.internal.err_cnt > #device.config.max_err
	    OR false
	);
END_FUNCTION

FUNCTION_BLOCK "mb_rtu"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      hardware_id : PORT;
      baud : UDInt := 9600;
      parity : Bool;   // enable even parity. false=no parity.
      timeout : Time := T#100ms;
      buffer_db_any : DB_ANY;
   END_VAR

   VAR_IN_OUT 
      buffer_variant : Variant;
      mb : "udt_mb";
   END_VAR

   VAR 
      comm_load {OriginalPartName := 'MB_COMM_LOAD'; LibVersion := '2.1'} : MB_COMM_LOAD;
      master {OriginalPartName := 'MB_MASTER'; LibVersion := '2.2'} : MB_MASTER;
   END_VAR


BEGIN
	#mb.const.app := false;
	
	#comm_load(REQ := NOT #comm_load.DONE AND NOT #master.BUSY,
	           "PORT" := #hardware_id,
	           BAUD := #baud,
	           PARITY := SEL(G := #parity, IN0 := 0, IN1 := 2),
	           RESP_TO := TIME_TO_UINT( #timeout ),
	           MB_DB := #master );
	
	#master(REQ := #comm_load.DONE AND NOT #master.BUSY AND NOT #mb.run.insert,
	        MB_ADDR := #mb.q.unit,
	        MODE := #mb.run.mode,
	        DATA_ADDR := #mb.run.data_addr,
	        DATA_LEN := #mb.q.d_len,
	        DONE => #mb.stat.done,
	        ERROR => #mb.stat.err,
	        STATUS => #mb.stat.status,
	        DATA_PTR := #buffer_variant );
	
	#mb.stat.timeout := #master.ERROR AND #master.STATUS = 16#80C8;
	// ------------------------
	#mb.const.buffer := #buffer_db_any; // VARIANT_TO_DB_ANY(in := #buffer_variant, err => #err);
	IF #mb.q.qid > #mb.run.qid_cnt THEN #mb.q.qid := 1; END_IF;
	#mb.run.qid_cnt := 0;
	
END_FUNCTION_BLOCK

FUNCTION "mb_read" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
//Read a dword, a Real or another 4 bytes datatype.
   VAR_INPUT 
      unit : USInt;
      d_addr : UInt;
   END_VAR

   VAR_IN_OUT 
      data : Variant;
      mb : "udt_mb";
   END_VAR

   VAR_TEMP 
      tmp_array : Array[1..2] of Word;
      tmp_dword : DWord;
      e : Int;
   END_VAR


BEGIN
	IF TypeOfElements(#data) = Word OR TypeOfElements(#data) = Int
	    OR TypeOfElements(#data) = UInt
	THEN
	    "mb_query"(unit := #unit,
	               fc := 3, // holding reg.
	               d_addr := UINT_TO_UDINT(#d_addr),
	               d_len := 0, // auto
	               data := #data,
	               mb := #mb);
	ELSE
	    "mb_query"(unit := #unit,
	               fc := 3,
	               d_addr := #d_addr,
	               d_len := 2,
	               data := #tmp_array,
	               mb := #mb);
	    
	    IF #mb.query_above.done THEN 
	        #tmp_dword := SHL_DWORD(IN := #tmp_array[1], N := 16)
	                        OR WORD_TO_DWORD(#tmp_array[2]);
	        IF TypeOfElements(#data) = DWord THEN
	            #e := MOVE_BLK_VARIANT(SRC := #tmp_dword, SRC_INDEX := 0,
	                        COUNT := 1, DEST_INDEX := 0, DEST => #data);
	        ELSE
	            "mb_change_datatype"(in := #tmp_dword, out := #data);
	        END_IF;
	    END_IF;
	END_IF;
END_FUNCTION

FUNCTION_BLOCK "mb_tcp"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      interface_id : HW_ANY;
      connection_id : CONN_OUC := 42;
      ip_addr : Array[1..4] of Byte := 192, 168, 1, 0;
      tcp_port : UInt := 502;   // enable even parity
      timeout : Real := 1.0;   // sec
      buffer_db_any : DB_ANY;
   END_VAR

   VAR_IN_OUT 
      buffer_variant : Variant;
      mb : "udt_mb";
   END_VAR

   VAR 
      client {OriginalPartName := 'MB_CLIENT'; LibVersion := '4.0'} : MB_CLIENT;
      tcon_ip_v4 {OriginalPartName := 'TCON_IP_v4'; LibVersion := '1.0'} : TCON_IP_v4;
      status2 : Word;
   END_VAR


BEGIN
	#mb.const.app := true;
	#tcon_ip_v4.InterfaceId := #interface_id;
	#tcon_ip_v4.ID := #connection_id;
	#tcon_ip_v4.RemoteAddress.ADDR := #ip_addr;
	#tcon_ip_v4.RemotePort := #tcp_port;
	
	#client.MB_Unit_ID := #mb.q.unit;
	#client.Rcv_Timeout := #timeout;
	#client(REQ := not #client.BUSY and #client.Connected and not #mb.run.insert,
	        DISCONNECT := #client.DISCONNECT,
	        MB_MODE := #mb.run.mode,
	        MB_DATA_ADDR := #mb.run.data_addr,
	        MB_DATA_LEN := #mb.q.d_len,
	        DONE => #mb.stat.done,
	        ERROR => #mb.stat.err,
	        STATUS => #mb.stat.status,
	        MB_DATA_PTR := #buffer_variant,
	        CONNECT := #tcon_ip_v4);
	
	if #client.STATUS <> 16#7004 and #client.STATUS <> 16#7005
	    and #client.STATUS <> 16#8200 
	then
	    #status2 := #client.STATUS ;
	end_if;
	    
	#mb.stat.timeout := #client.ERROR and #client.rcv_timer.Q;
	// ------------------------
	#mb.const.buffer := #buffer_db_any; 
	if #mb.q.qid > #mb.run.qid_cnt then #mb.q.qid := 1; end_if;
	#mb.run.qid_cnt := 0;
	
END_FUNCTION_BLOCK

FUNCTION "mb_query_place_holder" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_IN_OUT 
      mb : "udt_mb";
   END_VAR


BEGIN
	#mb.run.qid_cnt := #mb.run.qid_cnt + 1;
	
	IF #mb.run.qid_cnt = #mb.q.qid THEN
	    #mb.q.qid := #mb.q.qid + 1 ;
	    #mb.run.insert := true;
	END_IF;
	
END_FUNCTION

FUNCTION "mb_read_string" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
//Read a dword, a Real or another 4 bytes datatype.
   VAR_INPUT 
      unit : USInt;   // Device addr. (0 to 247)
      d_addr : UInt;   // Register addr. (without adding 40001)
   END_VAR

   VAR_IN_OUT 
      data : String;
      buffer : Variant;   // array of words
      mb : "udt_mb";
   END_VAR

   VAR_TEMP 
      c : Int;
      e : Int;
      "word" : Word;
   END_VAR


BEGIN
	"mb_query"(unit := #unit,
	           fc := 3,
	           d_addr := #d_addr,
	           d_len := 0,
	           data := #buffer,
	           mb := #mb);
	
	IF #mb.query_above.done THEN
	    FOR #c := 0 TO UDINT_TO_INT(CountOfElements(#buffer)) - 1 DO
	        #e := MOVE_BLK_VARIANT(SRC := #buffer, SRC_INDEX := #c,
	                               COUNT := 1, DEST => #word, DEST_INDEX := 0);
	        #data[#c * 2 + 1] := WORD_TO_BYTE(#word);
	        #data[#c * 2 + 2] := WORD_TO_BYTE(SHR(IN := #word, N := 8 ));
	    END_FOR;
	END_IF;
END_FUNCTION

FUNCTION "mb_write" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
//Write a dword, a Real or another 4 bytes datatype.
   VAR_INPUT 
      unit : USInt;   // Device addr. (0 to 247)
      d_addr : UInt;   // Register addr. (without adding 40001)
   END_VAR

   VAR_IN_OUT 
      data : Variant;
      mb : "udt_mb";
   END_VAR

   VAR_TEMP 
      tmp_array : Array[1..2] of Word;
      tmp_dword : DWord;
      e : Int;
   END_VAR


BEGIN
	IF TypeOfElements(#data) = Word OR TypeOfElements(#data) = Int
	    OR TypeOfElements(#data) = UInt
	THEN
	    "mb_query"(unit := #unit,
	               fc := 16, // holding reg.
	               d_addr := UINT_TO_UDINT(#d_addr),
	               d_len := 0, // auto
	               data := #data,
	               mb := #mb);
	ELSE
	    IF #mb.q.qid + 1 = #mb.run.qid_cnt THEN
	        IF TypeOfElements(#data) = DWord THEN
	            #e := MOVE_BLK_VARIANT(SRC := #data, COUNT := 1,
	                    SRC_INDEX := 0, DEST_INDEX := 0, DEST => #tmp_dword);
	        ELSE
	            "mb_change_datatype"(in := #data, out := #tmp_dword);
	        END_IF;
	        #tmp_array[1] := DWORD_TO_WORD(SHR(IN := #tmp_dword, N := 16));
	        #tmp_array[2] := DWORD_TO_WORD(#tmp_dword);
	    END_IF;
	    "mb_query"(unit := #unit,
	               fc := 16,
	               d_addr := #d_addr,
	               d_len := 2,
	               data := #tmp_array,
	               mb := #mb);
	END_IF;
END_FUNCTION

