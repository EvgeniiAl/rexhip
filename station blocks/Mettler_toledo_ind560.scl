FUNCTION_BLOCK "mettler_toledo_IND560"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT DB_SPECIFIC
      mb_addr : UInt := 255;
   END_VAR
   VAR_INPUT 
      iLoad_target_value : Real;
   END_VAR

   VAR_OUTPUT 
      qLoad_target_value_done : Bool;
   END_VAR

   VAR_IN_OUT 
      mb_query : "mb_query";
   END_VAR

   VAR DB_SPECIFIC
      sb : "mb_station_block_udt";
   END_VAR
   VAR 
      read_message_slot { ExternalWritable := 'False'} : Array[1..4] of Struct
         cmd_respons { ExternalWritable := 'False'} : Struct
            FP_input_indicator_1 { ExternalWritable := 'False'} : Bool;
            FP_input_indicator_2 { ExternalWritable := 'False'} : Bool;
            FP_input_indicator_3 { ExternalWritable := 'False'} : Bool;
            FP_input_indicator_4 { ExternalWritable := 'False'} : Bool;
            FP_input_indicator_5 { ExternalWritable := 'False'} : Bool;
            data_integrity { ExternalWritable := 'False'} : Bool;
            command_ack_1 { ExternalWritable := 'False'} : Bool;
            command_ack_2 { ExternalWritable := 'False'} : Bool;
         END_STRUCT;
         reserved { ExternalWritable := 'False'} : Byte;   // volt
         data { ExternalWritable := 'False'} : Real;
         scale_status { ExternalWritable := 'False'} : Struct
            x08_Enter_Key { ExternalWritable := 'False'} : Bool;
            x09_Input_1 { ExternalWritable := 'False'} : Bool;
            x10_Input_2 { ExternalWritable := 'False'} : Bool;
            x11_Input_3 { ExternalWritable := 'False'} : Bool;
            x12_Motion { ExternalWritable := 'False'} : Bool;
            x13_Net_Mode { ExternalWritable := 'False'} : Bool;
            x14_Data_Integrity_2 { ExternalWritable := 'False'} : Bool;
            x15_Data_OK { ExternalWritable := 'False'} : Bool;
            x00_Target_1 { ExternalWritable := 'False'} : Bool;
            x01_Comparator_1 { ExternalWritable := 'False'} : Bool;
            x02_Targe_2 { ExternalWritable := 'False'} : Bool;
            x03_Comparator_2 { ExternalWritable := 'False'} : Bool;
            x04_Target_3 { ExternalWritable := 'False'} : Bool;
            x05_Alway_true { ExternalWritable := 'False'} : Bool;
            x06_TE_bit_1 { ExternalWritable := 'False'} : Bool;
            x07_TE_bit_2 { ExternalWritable := 'False'} : Bool;
         END_STRUCT;
      END_STRUCT;
      write_message_slot { ExternalWritable := 'False'} : Array[1..4] of Struct
         cmd { ExternalWritable := 'False'} : UInt;
         data { ExternalWritable := 'False'} : Real;
      END_STRUCT;
      PF_input_indication : Array[1..4] of USInt;   // Floating point input indication
      command_ack : Array[1..4] of USInt;
      state_loadTargetValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      old_iLoad_target_value : Real;
      occupied_message_slots : Array[1..4] of Bool;
   END_VAR

   VAR_TEMP 
      c : Int;
      read_done : Bool;
      write_done : Bool;
      dommy_not_in_use : Struct
         x08_Start_abort_target_1 : Bool;
         x09_Message_display_mode_1 : Bool;
         x10_Message_display_mode_1 : Bool;
         x11_Message_display_mode_1 : Bool;
         x12_Output_1 : Bool;
         x13_Output_2 : Bool;
         x14_Output_3 : Bool;
         x15_Load_target : Bool;
         x00_Select_1 : Bool;
         x01_Select_2 : Bool;
         x02_Select_3 : Bool;
         x03_Load_tare_1 : Bool;
         x04_Clear_tare_1 : Bool;
         x05_Tare_1 : Bool;
         x06_Print_1 : Bool;
         x07_Zero_1 : Bool;
      END_STRUCT;
      slot : USInt;
   END_VAR


BEGIN
	// Mettler Toledo IND560 - Weighing Terminal
	
	// WARNING: This SB is just a draft and the block probably include errors !!
	
	// Necessary settings: ()
	// PLC -> Eth/IP - Modbus TCP -> IP-address
	// PLC -> Eth/IP - Modbus TCP -> Subnet-mask
	// PLC -> Data Format -> Byte order : standard
	// PLC -> Data Format -> Format     : Floating Point 
	
	// - Modbus tcp:
	//   https://bradysystems.com/wp-content/uploads/2012/10/IND560-PLC-Interface-Manual.pdf
	// - Product overview:
	//   http://www.atsackfillers.mobi/assets/ind560_ug_en_71209396_r04.pdf
	
	REGION Modbus    
	    "mb_station_block_header"(sb := #sb, mb_query := #mb_query);
	    #mb_query.mb_addr := #mb_addr;
	    
	    #mb_query(mode := #mb_query.c.mode.read,
	              data_addr := 400001,
	              data_ptr := #read_message_slot,
	              Done => #read_done);
	    
	    #mb_query(mode := #mb_query.c.mode.write,
	              data_addr := 401026,
	              data_ptr := #write_message_slot,
	              Done => #write_done);
	    
	    "mb_station_block_footer"(sb := #sb, mb_query := #mb_query);
	END_REGION
	
	REGION Read data fix     
	    FOR #c := 1 TO 4 DO
	        #PF_input_indication[#c].%X0 := #read_message_slot[#c].cmd_respons.FP_input_indicator_1;
	        #PF_input_indication[#c].%X1 := #read_message_slot[#c].cmd_respons.FP_input_indicator_2;
	        #PF_input_indication[#c].%X2 := #read_message_slot[#c].cmd_respons.FP_input_indicator_3;
	        #PF_input_indication[#c].%X3 := #read_message_slot[#c].cmd_respons.FP_input_indicator_4;
	        #PF_input_indication[#c].%X4 := #read_message_slot[#c].cmd_respons.FP_input_indicator_5;
	        
	        #command_ack[#c].%X0 := #read_message_slot[#c].cmd_respons.command_ack_1;
	        #command_ack[#c].%X1 := #read_message_slot[#c].cmd_respons.command_ack_2;
	    END_FOR;
	END_REGION
	
	REGION Load target value
	    // Load target value, for scale 1. Page 143, table B-6
	    
	    #slot := 1; // Use message slot 1.
	    CASE #state_loadTargetValue OF
	            
	        0:  // Waiting for start.
	            #qLoad_target_value_done := false;
	            IF #old_iLoad_target_value <> #iLoad_target_value
	                AND NOT #occupied_message_slots[#slot]
	            THEN // Next step if value change
	                #state_loadTargetValue += 1;
	                #occupied_message_slots[#slot] := true;
	            END_IF;
	            
	        1:  // #1 PLC loads floating point value first
	            #write_message_slot[#slot].cmd := 0;
	            #write_message_slot[#slot].data := #iLoad_target_value;
	            #state_loadTargetValue += 1;
	        2:
	            #state_loadTargetValue += BOOL_TO_INT(#write_done);
	            
	        3:  // #2 PLC sends command to set target 1 cutoff value 
	            #write_message_slot[#slot].cmd := 110;
	            #state_loadTargetValue += 1;
	        4:
	            #state_loadTargetValue += BOOL_TO_INT(#write_done);
	            
	        5:  // #3 IND560 terminal sees new command, loads the value into the target
	            //    and ends a return message to indicate the new target value.
	            #state_loadTargetValue +=
	            BOOL_TO_INT(#read_done
	                        AND #command_ack[#slot] = 1
	                        AND #PF_input_indication[#slot] = 13
	                        AND #read_message_slot[#slot].data = #write_message_slot[#slot].data);
	            
	        6:  // #4  PLC instructs IND560 terminal to start “using” new target value
	            #write_message_slot[#slot].cmd := 114;
	            #state_loadTargetValue += 1;
	        7:
	            #state_loadTargetValue += BOOL_TO_INT(#write_done);
	            
	        8:  // #5 IND560 terminal sees new command
	            #write_message_slot[#slot].cmd := 0;
	            
	            #state_loadTargetValue +=
	            BOOL_TO_INT(#read_done
	                        AND #command_ack[#slot] = 2
	                        AND #PF_input_indication[#slot] = 30
	                        AND #read_message_slot[#slot].data = 0);
	            
	        ELSE: // Back to start.
	            #occupied_message_slots[#slot] := false;
	            #state_loadTargetValue := 0;
	            #qLoad_target_value_done := true;
	            // The start signal should need to be set back false before next
	            // exec. else the sequence will start over.
	    END_CASE;
	    #old_iLoad_target_value := #iLoad_target_value;
	END_REGION
	
	REGION Doc
	  (* 
	  === Floating Point Input Indication ===
	  0   Gross Weight       
	  1   Net Weight       
	  2   Tare Weight
	  3   Fine Gross Weight
	  4   Fine Net Weight
	  5   Fine Tare Weight 
	  6   Not used 
	  7   Custom field #1  
	  8   Custom field #2
	  9   Custom field #3
	  10  Custom field #4 
	  11  Low-pass filter frequency 
	  12  Notch filter frequency 
	  13  Target value
	  14  +Tolerance value
	  15  Fine feed value 
	  16  -Tolerance value 
	  17  + and - Tolerance values 
	  18  Primary units, low increment size 
	  19  Weigh-in target value 
	  20  Weigh-in fine feed value 
	  21  Weigh-in spill value  
	  22  Weigh-in +tolerance value 
	  23  Weigh-in -tolerance value 
	  24  Weigh-out target value
	  25  Weigh-out fine feed value 
	  26  Weigh-out spill value 
	  27  Weigh-out +tolerance value 
	  28  Weigh-out -tolerance value
	  29  Last indicator error code 
	  30  No data response command successful 
	  31  Invalid Command
	  *)    
	END_REGION
	
END_FUNCTION_BLOCK

