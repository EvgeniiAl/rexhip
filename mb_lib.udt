TYPE "udt_mb_device"
VERSION : 0.1
   STRUCT
      unit : USInt;   // (not in use)
      disable : Bool;   // Skip all queries and reset
      qError : Bool;   // All types of errors including comError
      qComError : Bool;   // Communication error, set true after x repeating tries
      conf : Struct   // Configuration
         max_qComError { S7_SetPoint := 'True'} : USInt := 2;   // Max repeating timeout errors before qComError is set
         tof_qErrror { S7_SetPoint := 'True'} : Time := T#2s;   // Length of the qError puls
         exec_all_quries : Bool;
      END_STRUCT;
      log : Struct   // Logging
         done_cnt : UDInt;   // Successfully queries counter for this device
         done_dtl {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;   // DTL for last successfully querie
         err_cnt : UDInt;   // Failed queries counter for this device
         err_dtl {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;   // DTL for last failed querie
         err_status : Word;   // Status code from mb_master or mb_client
         err_timeout : Bool;   // For last failed querie
         err_d_addr : UDInt;   // d_addr for last failed querie, handy for troubleshooting
      END_STRUCT;
      intern : Struct   // Stored values for Internal use
         header_qid { S7_HMI_Visible := 'False'} : UInt;   // qid value at device header
         timeout_cnt : USInt;   // Repeating timeout errors
         err_dtl {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;   // DTL of last failed querie, in system time
         offset_qid : UInt := 1;   // Device query id.
         insert_id { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt;   // snap shot of insert_id in mb at header
         recive_id { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt;   // snap shot of recive_id in mb at header
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "udt_mb"
VERSION : 0.1
   STRUCT
      q : Struct   // Query
         qid : UInt := 1;   // query id
         unit : UInt := 1;   // Station address
         "fc" : UInt := 3;   // Function code
         d_addr : UDInt;   // Data address
         d_len : UInt := 1;   // Data length
      END_STRUCT;
      run : Struct   // Constantly changing variables
         qid_cnt : UInt;   // Query id cnt. increase for each query, reset in controller. One loop each scan
         mode : USInt := 0;   // from fc
         data_addr : UDInt;   // from d_addr
         inc : Bool;   // inc. qid if a unsync resualt
         insert : Bool := true;   // insert query param
      END_STRUCT;
      fix : Struct   // Static varables.
         buffer_db : DB_ANY;
      END_STRUCT;
      device : Struct   // Advanced timeout handler
         did_cnt : UInt;   // Device id cnt
         did_retry : UInt := 1;   // Retry device id, qComError
         retry_finished : Bool;
         insert_id : USInt;
         recive_id : USInt;   // toggle when recived
         recived_d_addr : UDInt;
         did : UInt;
      END_STRUCT;
      conf : Struct   // Configuration
         buffer_handler : Bool := true;   // enable buffer handler
      END_STRUCT;
      log : Struct   // Logging
         unsync : USInt;
      END_STRUCT;
      stat : Struct   // Status of last query
         query_above : Bool;   // Refer to the query that is above in the code.
         done : Bool;   // Successfully
         error : Bool;   // Failed (not timeout)
         timeout : Bool;   // Communication problems
         done_or_error : Bool;   // done or error
         error_or_timeout : Bool;   // error with or without timeout
         done_or_error_or_timeout : Bool;   // Done, error or timeout
         status : Word;   // status word of mb_master or mb_client
      END_STRUCT;
      "fc" : Struct   // Function codes
         skip_query { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 0;   // 0
         read_output_bits { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 1;   // 1 - (coils)
         read_input_bits { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 2;   // 2 - (discrete inputs)
         read_holding_reg { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 3;   // 3
         read_input_reg { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 4;   // 4
         write_single_output_bit { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 5;   // 5 - (coil)
         write_single_holding_reg { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 6;   // 6
         write_output_bits { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 15;   // 15 - (coils)
         write_holding_reg { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 16;   // 16
         modicon_read { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 200;   // 200
         modicon_write_single { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 201;   // 201
         modicon_write { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 202;   // 202
      END_STRUCT;
      c : Struct   // Other constants
         auto_len : UInt := 0;   // 0 - Length will be callculated automatically.
      END_STRUCT;
   END_STRUCT;

END_TYPE

