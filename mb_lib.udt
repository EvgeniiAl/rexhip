TYPE "udt_mb_common"
VERSION : 0.1
   STRUCT
      in : Struct   // Inputs
         unit : USInt;   // (not in use)
         disable : Bool;   // Skip all queries and reset
      END_STRUCT;
      out : Struct   // Outputs
         error : Bool;   // All errors, including communication errors
         communication_error : Bool;   // only communication errors
         finnish : Bool;   // qid is handed over to next device.
      END_STRUCT;
      conf : Struct   // Configuration
         errror_flag_puls_length { S7_SetPoint := 'True'} : Time := T#2s;   // Length of the errror_flag puls
         max_repeating_timeouts { S7_SetPoint := 'True'} : USInt := 2;   // before communication_error flag is set
         exec_all_quries { S7_SetPoint := 'True'} : Bool;   // Execute all queries in the device block for each loop.
      END_STRUCT;
      log : Struct   // Logging for development and debugging.
         done_cnt : UDInt;   // Successfully queries counter for this device
         done_dtl {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;   // DTL for last successfully querie
         error_cnt : UDInt;   // Failed queries counter for this device
         error_dtl {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;   // DTL for last failed querie
         error_status : Word;   // Status code from mb_master or mb_client
         error_timeout : Bool;   // For the last failed querie
         error_d_addr : UDInt;   // d_addr for last failed querie; handy for troubleshooting
      END_STRUCT;
      z : Struct   // Internal states.
         header_qid : UInt;   // qid value at device header
         timeout_cnt : USInt;   // Repeating timeout errors
         error_dtl {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;   // DTL of last failed querie, in system time
         offset_qid : UInt := 1;   // Device query id.
         insert_id : USInt;   // snap shot of insert_id in mb at header
         recive_id : USInt;   // snap shot of recive_id in mb at header
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "udt_mb"
VERSION : 0.1
   STRUCT
      c : Struct   // Constants
         read : Struct   // Read: 1, 2, 3, 4
            output_bits { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 1;   // 1 - (coils)
            input_bits { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 2;   // 2 - (discrete inputs)
            holding_reg { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 3;   // 3
            input_reg { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 4;   // 4
         END_STRUCT;
         write : Struct   // Write: 5, 6, 15, 16
            single_output_bit { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 5;   // 5 - (coil) (when len. is eq. to 1)
            single_holding_reg { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 6;   // 6 (when len. is eq. to 1)
            output_bits { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 15;   // 15 - (coils)
            holding_reg { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 16;   // 16
         END_STRUCT;
         mode : Struct   // Modicon convention addressing. (eg: hold.reg. start at 40001)
            read { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 200;   // Mode 0
            write_single { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 201;   // Mode 1 (fc: 5, 6) (when len. is eq. to 1)
            write { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 202;   // Mode 2 (fc: 15, 16)
         END_STRUCT;
         skip_query { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 0;   // 0
         auto_len : UInt := 0;   // 0 - Length will be callculated automatically.
      END_STRUCT;
      conf : Struct   // Configuration
         buffer_handler : Bool := true;   // enable buffer handler
      END_STRUCT;
      log : Struct   // Logging
         unsync : USInt;
      END_STRUCT;
      stat : Struct   // Status of last executed query
         done : Bool;   // Successfull
         error : Bool;   // Error, including timeout error
         done_or_error : Bool;   // Done, error or timeout
         timeout : Bool;   // Only timeout error
         exception : Bool;   // error except timeout
         done_or_exception : Bool;   // Done or error, except timeout
         query_above : Bool;   // Refer to the query above in the code.
         status : Word;   // status word of mb_master or mb_client
      END_STRUCT;
      z : Struct   // Internal states.
         buffer : Array[0..250] of Byte;   // Buffer
         q : Struct   // Query params
            qid : UInt := 1;   // query id
            unit : UInt := 1;   // Station address
            "fc" : UInt := 3;   // Function code
            d_addr : UDInt;   // Data address
            d_len : UInt := 1;   // Data length
         END_STRUCT;
         run : Struct   // Constantly changing variables
            qid_cnt : UInt;   // Query id cnt. increase for each query, reset in controller. One loop each scan
            mode : USInt := 0;   // from fc
            data_addr : UDInt;   // from d_addr
            inc : Bool;   // inc. qid if a unsync resualt
            insert : Bool := true;   // insert query param
         END_STRUCT;
         com : Struct   // tmp. storate device header and footer.
            did_cnt : UInt;   // Device id cnt
            did_retry : UInt := 1;   // Retry device id, qComError
            retry_finished : Bool;
            insert_id : USInt;
            recive_id : USInt;   // toggle when recived
            recived_d_addr : UDInt;
            did : UInt;
            skip_cnt : Int;
            tmp_insert : Bool;
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

 
