TYPE "udt_mb_device"
VERSION : 0.1
   STRUCT
      enable : Bool := true;
      unit : Bool;   // (not in use)
      qError : Bool;   // All types of errors including comError
      qComError : Bool;   // Communication error
      config : Struct
         max_qComError { S7_SetPoint := 'True'} : USInt := 3;   // Max repeating timeout errors before qComError is set
         tof_qErrror { S7_SetPoint := 'True'} : Time := T#2s;   // Length of the qError_tof puls
      END_STRUCT;
      log : Struct
         done_cnt : UDInt;
         done_dtl {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;
         err_cnt : UDInt;
         err_dtl {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;
         err_status : Word;
         err_timeout : Bool;
         err_d_addr : UDInt;
      END_STRUCT;
      intern : Struct
         range_start_qid : UInt;
         range_end_qid : UInt;
         err_cnt : USInt;   // repeating errors
         tmp_exec_cnt : UDInt;
         skip : Bool;
         err_dtl {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "udt_mb"
VERSION : 0.1
   STRUCT
      q : Struct   // query
         unit : USInt := 1;
         "fc" : UInt := 3;   // function code
         d_addr : UDInt;
         d_len : UInt := 1;
         qid : UInt := 1;   // query id
         next : UInt := 1;   // id of next query to be exec.
         priority : UInt;
      END_STRUCT;
      run : Struct
         mode : USInt;
         data_addr : UDInt;
         qid_cnt : UInt;   // query id cnt, one cycle each plc-scan.
         insert : Bool := true;   // insert query param
         exec_cnt : UDInt;   // Execute cnt.
         exec_d_addr : UDInt;
      END_STRUCT;
      fix : Struct   // Static varables.
         buffer_db : DB_ANY;
         app : SInt;
         queries : UInt;   // Number of queries
      END_STRUCT;
      status : Struct
         done : Bool;
         error : Bool;
         timeout : Bool;
         status : Word;
      END_STRUCT;
      query_above : Struct
         done : Bool;
         error : Bool;
         insert : Bool;
      END_STRUCT;
      options : Struct
         buffer_handler : Bool;
      END_STRUCT;
      "fc" : Struct   // Function codes
         skip_query { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 0;   // 0
         read_output_bits { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 1;   // 1 - (coils)
         read_input_bits { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 2;   // 2 - (discrete inputs)
         read_holding_reg { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 3;   // 3
         read_input_reg { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 4;   // 4
         write_single_output_bit { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 5;   // 5 - (coil)
         write_single_holding_reg { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 6;   // 6
         write_output_bits { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 15;   // 15 - (coils)
         write_holding_reg { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 16;   // 16
         mode_read { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 200;   // 200
         mode_write_single { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 201;   // 201
         mode_write { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} : USInt := 202;   // 202
      END_STRUCT;
      c : Struct   // Other constants
         auto_len : UInt := 0;   // 0
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION "mb_buffer_handler" : Void
{ S7_Optimized_Access := 'FALSE' }
VERSION : 1.0
   VAR_INPUT 
      action : SInt;
      buffer_db : DB_ANY;
   END_VAR

   VAR_IN_OUT 
      data : Variant;
      bytes : DInt;
   END_VAR

   VAR_TEMP 
      "array" : Array[0..300] of Byte;
      e : Int;
      c : Int;
   END_VAR


BEGIN
	CASE #action OF
	    1:  // Count bytes             
	        #bytes := 0;
	        #e := Serialize(SRC_VARIABLE := #data,
	                        DEST_ARRAY => #array,
	                        POS := #bytes);
	    2:  // Write buffer    
	        #bytes := 0;
	        #e := Serialize(SRC_VARIABLE := #data,
	                        DEST_ARRAY => #array,
	                        POS := #bytes);
	        FOR #c := 0 TO #bytes - 1 DO
	            POKE(area := 16#84,
	                 dbNumber := #buffer_db,
	                 byteOffset := #c,
	                 value := #array[#c]);
	        END_FOR;
	    3:  // Read buffer        
	        IF #bytes = 0 THEN
	            #e := Serialize(SRC_VARIABLE := #data,
	                            DEST_ARRAY => #array,
	                            POS := #bytes);
	        END_IF;
	        FOR #c := 0 TO #bytes - 1 DO
	            #array[#c] := PEEK(area := 16#84,
	                               dbNumber := #buffer_db,
	                               byteOffset := #c);
	        END_FOR;
	        #bytes := 0;
	        #e := Deserialize(SRC_ARRAY := #array,
	                          DEST_VARIABLE => #data,
	                          POS := #bytes);
	END_CASE;
END_FUNCTION

FUNCTION "mb_query" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT 
      unit : USInt;   // Device addr. (0 to 247)
      "fc" : USInt;   // Function code: 1,2,3,4,5,6,15,16. (siemens mode shifted to 200 - 202)
      d_addr : UDInt;   // Data addr. (raw telegram value, 0-65535)
      d_len : UInt;   // Data len. 0=>Auto detect
   END_VAR

   VAR_IN_OUT 
      data : Variant;   // Bytes and bools has to add up to whole word(s)
      mb : "udt_mb";
   END_VAR

   VAR_TEMP 
      c : Int;
      e : Int;
      tmp_len : UInt;
      bytes : DInt;
   END_VAR


BEGIN
	// Lightweight Modbus Abstraction Layer Library. 
	// Author:   Ola Bjørnli
	// Version:  0.2_beta16
	// License:  MIT-license
	// Web:      http://mb.sn7.no
	//           http://github.com/olab84/sn7mb
	
	#mb.query_above.done := false;
	#mb.query_above.error := false;
	#mb.query_above.insert := false;
	#mb.run.qid_cnt := #mb.run.qid_cnt + 1;
	IF #mb.run.qid_cnt <> #mb.q.qid THEN
	    RETURN;
	ELSIF #fc = 0 THEN
	    #mb.run.insert := true;
	    #mb.q.qid := #mb.q.next + BOOL_TO_UINT(#mb.q.next = #mb.q.qid);
	    #mb.options.buffer_handler := true;
	    RETURN;
	END_IF;
	
	IF #d_len = 0 AND #mb.options.buffer_handler AND // auto  
	    (#mb.run.insert OR #mb.status.done OR #mb.status.error)
	THEN   
	    "mb_buffer_handler"(action := 1, // count
	                        buffer_db := 0,
	                        data := #data,
	                        bytes := #bytes);
	    CASE #fc OF
	        1, 2, 5, 15: #tmp_len := DINT_TO_UINT( #bytes * 8 );
	        3, 4, 6, 16: #tmp_len := DINT_TO_UINT( #bytes / 2 );
	        200..202:
	            CASE #d_addr OF
	                1..9999, 10001..19999:
	                    #tmp_len := DINT_TO_UINT( #bytes * 8 );
	                30001..39999, 30001..49999, 400001..465535:
	                    #tmp_len := DINT_TO_UINT( #bytes / 2 );
	            END_CASE;
	    END_CASE;
	ELSE
	    #tmp_len := #d_len;
	    #bytes := #d_len * 2;
	END_IF;
	
	IF #mb.run.insert THEN
	    CASE #fc OF
	        1:  // Read output bits 
	            #mb.run.mode := 0;
	            #mb.run.data_addr := 1 + #d_addr;
	        2:  // Read input bits
	            #mb.run.mode := 0;
	            #mb.run.data_addr := 10001 + #d_addr;
	        3:  // Read holding reg.
	            #mb.run.mode := 0;
	            #mb.run.data_addr := 400001 + #d_addr;
	        4:  // Read input word
	            #mb.run.mode := 0;
	            #mb.run.data_addr := 30001 + #d_addr;
	        5:  // Writing a single output bit
	            #mb.run.mode := 1;
	            #mb.run.data_addr := 1 + #d_addr;
	        6:  // Writing a single holding register
	            #mb.run.mode := 1;
	            #mb.run.data_addr := 400001 + #d_addr;
	        15: // Writing multiple output bits
	            #mb.run.mode := 2;
	            #mb.run.data_addr := 1 + #d_addr;
	        16: // Writing multiple holding registers
	            #mb.run.mode := 2;
	            #mb.run.data_addr := 400001 + #d_addr;
	        200..202: // Siemens mode 0-2 replaced by 200-202  
	            #mb.run.mode := #fc - 200;
	            #mb.run.data_addr := #d_addr;
	        ELSE
	            #mb.run.mode := #fc;
	            #mb.run.data_addr := #d_addr;
	    END_CASE;
	    #mb.q.unit := #unit;
	    #mb.q.fc := #fc;
	    #mb.q.d_addr := #d_addr;
	    #mb.q.d_len := #tmp_len;
	    IF (#mb.run.mode = 1 OR #mb.run.mode = 2)
	        AND #mb.options.buffer_handler
	    THEN
	        "mb_buffer_handler"(
	            action := 2, // write
	            buffer_db := #mb.fix.buffer_db,
	            data := #data ,
	            bytes := #bytes );
	    END_IF;
	    #mb.run.insert := false;
	    #mb.q.next := #mb.q.qid + 1 ;
	    #mb.query_above.insert := true;
	    
	ELSIF #mb.status.done OR #mb.status.error THEN
	    IF #mb.q.unit = #unit
	        AND #mb.q.fc = #fc
	        AND #mb.q.d_addr = #d_addr
	        AND #mb.q.d_len = #tmp_len
	    THEN
	        IF #mb.status.done THEN
	            IF #mb.run.mode = 0
	                AND #mb.options.buffer_handler
	            THEN
	                "mb_buffer_handler"(
	                    action := 3, // read
	                    buffer_db := #mb.fix.buffer_db,
	                    data := #data,
	                    bytes := #bytes );
	            END_IF;
	            #mb.query_above.done := true;
	        ELSIF #mb.status.error THEN
	            #mb.query_above.error := true;
	        END_IF;
	        #mb.run.exec_d_addr := #d_addr;
	        #mb.run.exec_cnt := #mb.run.exec_cnt + 1;
	    END_IF;
	    #mb.run.insert := true;
	    #mb.q.qid := #mb.q.next + BOOL_TO_UINT(#mb.q.next = #mb.q.qid);
	END_IF;
	
	#mb.options.buffer_handler := true;
END_FUNCTION

FUNCTION "mb_device_header" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_IN_OUT 
      device : "udt_mb_device";
      mb : "udt_mb";
   END_VAR


BEGIN
	#device.intern.tmp_exec_cnt := #mb.run.exec_cnt;
	#device.intern.skip := false;
	
	IF #mb.q.qid >= #device.intern.range_start_qid
	    AND #mb.q.qid <= #device.intern.range_end_qid
	    AND (  NOT #mb.run.insert AND #mb.status.timeout
	        OR NOT #device.enable )
	THEN
	    #mb.q.qid := 16#fff0;
	    #device.intern.skip := true;
	    #device.intern.tmp_exec_cnt := #device.intern.tmp_exec_cnt
	        + BOOL_TO_UDINT(#mb.status.timeout);
	END_IF;
	
	#device.intern.range_start_qid := #mb.run.qid_cnt + 1;
END_FUNCTION

FUNCTION "mb_device_footer" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_IN_OUT 
      device : "udt_mb_device";
      mb : "udt_mb";
   END_VAR

   VAR_TEMP 
      e : Int;
      tmp_error : Bool;
      rd_sys_t {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;
      tmp_err : Bool;
   END_VAR


BEGIN
	IF NOT #device.enable THEN
	    #device.qError := false;
	    #device.intern.err_cnt := 0;
	ELSIF #mb.run.exec_cnt <> #device.intern.tmp_exec_cnt THEN
	    IF #mb.status.done THEN
	        #device.log.done_cnt := #device.log.done_cnt + 1;
	        #e := RD_LOC_T(#device.log.done_dtl);
	        #device.intern.err_cnt := 0;
	        #device.log.err_timeout := false;
	    ELSIF #mb.status.error THEN
	        #device.log.err_cnt := #device.log.err_cnt + 1;
	        #e := RD_LOC_T(#device.log.err_dtl);
	        #device.log.err_status := #mb.status.status;
	        #device.log.err_d_addr := #mb.run.exec_d_addr;
	        #device.intern.err_cnt := SEL(G := #mb.status.timeout,
	              IN0 := 0,
	              IN1 := MIN(IN1 := #device.intern.err_cnt + 1,
	                         IN2 := 250));
	        #device.log.err_timeout := #mb.status.timeout;
	        #device.qError := true;
	        #e := RD_SYS_T(#device.intern.err_dtl);
	        #tmp_err := true;
	    END_IF;
	END_IF;
	
	IF #device.qError AND NOT #tmp_err THEN
	    #e := RD_SYS_T(#rd_sys_t);
	    #device.qError := #device.config.tof_qErrror <> 0
	    AND #rd_sys_t < #device.intern.err_dtl
	    + #device.config.tof_qErrror;
	END_IF;
	#device.qComError :=
	#device.intern.err_cnt > #device.config.max_qComError;
	
	IF #device.intern.skip THEN
	    #mb.q.qid := #mb.run.qid_cnt + 1; 
	    #mb.run.insert := true;
	    #mb.options.buffer_handler := true;
	    #mb.query_above.done := false;
	    #mb.query_above.error := false;
	    #mb.query_above.insert := false;
	END_IF;
	
	#device.intern.range_end_qid := #mb.run.qid_cnt;
	#device.intern.skip := false;
END_FUNCTION

FUNCTION_BLOCK "mb_tcp_controller"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT 
      interface : HW_ANY;
      conn_id : CONN_OUC := 123;   // connection_id
      ip_addr : Array[1..4] of Byte := 192, 168, 1, 0;
      tcp_port : UInt := 502;   // enable even parity
      timeout : Time := T#2s;   // sec
      buffer_db_any : DB_ANY;
   END_VAR

   VAR_OUTPUT 
      qError : Bool;
   END_VAR

   VAR_IN_OUT 
      buffer_variant : Variant;
      mb : "udt_mb";
   END_VAR

   VAR 
      client {OriginalPartName := 'MB_CLIENT'; LibVersion := '4.0'} : MB_CLIENT;
      tcon_ip_v4 {OriginalPartName := 'TCON_IP_v4'; LibVersion := '1.0'} : TCON_IP_v4;
      ton_timeout {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : TON_TIME;
      ton_timeout_q : Bool;
      tdiscon {OriginalPartName := 'T_DISCON'; LibVersion := '2.1'} : TDISCON;
   END_VAR

   VAR_TEMP 
      tmp_reconnect_after : Bool;
   END_VAR


BEGIN
	// #mb.fix.app := 21;
	
	#tcon_ip_v4.InterfaceId := #interface;
	#tcon_ip_v4.ID := #conn_id;
	#tcon_ip_v4.RemoteAddress.ADDR := #ip_addr;
	#tcon_ip_v4.RemotePort := #tcp_port;
	
	#tdiscon(REQ := #client.ERROR AND #client.STATUS = 16#80A3,
	         ID := #conn_id);
	IF #tdiscon.BUSY THEN #client.DISCONNECT := true;
	ELSIF #tdiscon.DONE THEN #client.DISCONNECT := false;
	END_IF;
	
	#client.MB_Unit_ID := #mb.q.unit;
	#client.Rcv_Timeout := UINT_TO_REAL(TIME_TO_UINT(#timeout)) / 1000;
	#client(REQ := NOT #client.BUSY AND NOT #mb.run.insert AND NOT #client.DISCONNECT,
	        DISCONNECT := #client.DISCONNECT,
	        MB_MODE := #mb.run.mode,
	        MB_DATA_ADDR := #mb.run.data_addr,
	        MB_DATA_LEN := #mb.q.d_len,
	        DONE => #mb.status.done,
	        ERROR => #mb.status.error,
	        STATUS => #mb.status.status,
	        MB_DATA_PTR := #buffer_variant,
	        CONNECT := #tcon_ip_v4);
	
	#ton_timeout(IN := NOT #mb.run.insert
	             AND (NOT #mb.status.done OR NOT #mb.status.error),
	             PT := #timeout,
	             Q => #ton_timeout_q);
	IF #ton_timeout_q THEN
	    #mb.status.error := true;
	    #mb.status.timeout := true;
	    RESET_TIMER(#ton_timeout);
	ELSE
	    #mb.status.timeout := #mb.status.error
	        AND (#mb.status.status = 16#818C
	            OR #mb.status.status = 16#80C8);
	END_IF;
	
	// ------------------------
	#qError := #mb.status.error;
	#mb.fix.buffer_db := #buffer_db_any;
	IF #mb.q.qid > #mb.run.qid_cnt THEN #mb.q.qid := 1; END_IF;
	#mb.fix.queries := #mb.run.qid_cnt;
	#mb.run.qid_cnt := 0;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "mb_rtu_controller"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT 
      hardware : PORT;   // hardware id
      baud : UDInt := 9600;
      parity : Bool := true;   // enable even parity. false=no parity.
      timeout : Time := T#500ms;
      buffer_db_any : DB_ANY;
   END_VAR

   VAR_OUTPUT 
      qError : Bool;
   END_VAR

   VAR_IN_OUT 
      buffer_variant : Variant;
      mb : "udt_mb";
   END_VAR

   VAR 
      comm_load {OriginalPartName := 'MB_COMM_LOAD'; LibVersion := '2.1'} : MB_COMM_LOAD;
      master {OriginalPartName := 'MB_MASTER'; LibVersion := '2.2'} : MB_MASTER;
   END_VAR


BEGIN
	// #mb.fix.app := 11;
	
	#comm_load(REQ := NOT #comm_load.DONE
	                AND NOT #master.BUSY,
	           "PORT" := #hardware,
	           BAUD := #baud,
	           PARITY := SEL(G := #parity,
	                         IN0 := 0, IN1 := 2),
	           RESP_TO := TIME_TO_UINT( #timeout ),
	           MB_DB := #master );
	
	#master(REQ := #comm_load.DONE
	            AND NOT #master.BUSY
	            AND NOT #mb.run.insert,
	        MB_ADDR := #mb.q.unit,
	        MODE := #mb.run.mode,
	        DATA_ADDR := #mb.run.data_addr,
	        DATA_LEN := #mb.q.d_len,
	        DONE => #mb.status.done,
	        ERROR => #mb.status.error,
	        STATUS => #mb.status.status,
	        DATA_PTR := #buffer_variant );
	
	#mb.status.timeout :=
	#master.ERROR AND #master.STATUS = 16#80C8;
	// ------------------------
	#qError := #mb.status.error;
	#mb.fix.buffer_db := #buffer_db_any;
	IF #mb.q.qid > #mb.run.qid_cnt THEN #mb.q.qid := 1; END_IF;
	#mb.fix.queries := #mb.run.qid_cnt;
	#mb.run.qid_cnt := 0;
END_FUNCTION_BLOCK

