FUNCTION "mb_buffer_handler" : Void
{ S7_Optimized_Access := 'FALSE' }
VERSION : 1.0
   VAR_INPUT 
      action : SInt;
      buffer_db : DB_ANY;
   END_VAR

   VAR_IN_OUT 
      data : Variant;
      bytes : DInt;
   END_VAR

   VAR_TEMP 
      buffer2 : Array[0..300] of Byte;
      e : Int;
      c : Int;
   END_VAR


BEGIN
	// The FC do 3 diffrent actions.
	CASE #action OF
	    1:  // Count bytes             
	        #bytes := 0;
	        #e := Serialize(SRC_VARIABLE := #data,
	                        DEST_ARRAY => #buffer2,
	                        POS := #bytes);
	    2:  // Write to buffer    
	        #bytes := 0;
	        #e := Serialize(SRC_VARIABLE := #data,
	                        DEST_ARRAY => #buffer2,
	                        POS := #bytes);
	        FOR #c := 0 TO #bytes - 1 DO
	            // Copy the content of the buffer inside this FC to the buffer db.
	            POKE(area := 16#84,
	                 dbNumber := #buffer_db,
	                 byteOffset := #c,
	                 value := #buffer2[#c]);
	        END_FOR;
	    3:  // Read from buffer        
	        IF #bytes = 0 THEN
	            // 0 => auto. Calculate have many bytes #data consist of.
	            #e := Serialize(SRC_VARIABLE := #data,
	                            DEST_ARRAY => #buffer2,
	                            POS := #bytes);
	        END_IF;
	        
	        // Copy the content from the buffer db in to the buffer inside
	        // this FC.
	        FOR #c := 0 TO #bytes - 1 DO
	            #buffer2[#c] := PEEK(area := 16#84,
	                                 dbNumber := #buffer_db,
	                                 byteOffset := #c);
	        END_FOR;
	        #bytes := 0;
	        #e := Deserialize(SRC_ARRAY := #buffer2,
	                          DEST_VARIABLE => #data,
	                          POS := #bytes);
	END_CASE;
END_FUNCTION

FUNCTION "mb_query" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT 
      unit : UInt;   // Device addr. (0 to 247)
      "fc" : USInt;   // Function code: 1,2,3,4,5,6,15,16. (siemens mode shifted to 200 - 202)
      d_addr : UDInt;   // Data addr. (raw telegram value, 0-65535)
      d_len : UInt;   // Data len. 0=>Auto detect
   END_VAR

   VAR_IN_OUT 
      data : Variant;   // Bytes and bools has to add up to whole word(s)
      mb : "udt_mb";
   END_VAR

   VAR_TEMP 
      c : Int;
      e : Int;
      tmp_len : UInt;
      bytes : DInt;
   END_VAR


BEGIN
	// Lightweight Modbus Abstraction Layer Library. 
	// Author:   Ola Bjørnli
	// Version:  0.3_beta29
	// License:  MIT-license
	// Web:      http://mb.sn7.no
	//           http://github.com/olab84/sn7mb
	
	#mb.query_above.done := false;
	#mb.query_above.error := false;
	#mb.run.qid_cnt := #mb.run.qid_cnt + 1;
	
	// qid_cnt is increased for every query (above) and reset back
	// to zero at the controller. qid is only increased when a query
	// finnish. This two varables create a token together, telling
	// witch query that should execute.
	IF #mb.run.qid_cnt <> #mb.q.qid THEN
	    RETURN;
	ELSIF #fc = 0 THEN // 0 => skip query
	    #mb.run.insert := true;
	    #mb.q.qid := #mb.q.qid + 1;
	    #mb.conf.buffer_handler := true;
	    RETURN;
	END_IF;
	
	// d_len=0 => Automatically calculate the length based on the
	// size of data.
	IF #d_len = 0 AND #mb.conf.buffer_handler AND 
	    (#mb.run.insert OR #mb.status.done OR #mb.status.error)
	THEN
	    "mb_buffer_handler"(action := 1, // Count bytes.
	                        buffer_db := 0,
	                        data := #data,
	                        bytes := #bytes);
	    CASE #fc OF
	        1, 2, 5, 15: #tmp_len := DINT_TO_UINT( #bytes * 8 );
	        3, 4, 6, 16: #tmp_len := DINT_TO_UINT( #bytes / 2 );
	        200..202:
	            CASE #d_addr OF
	                1..9999, 10001..19999:
	                    #tmp_len := DINT_TO_UINT( #bytes * 8 );
	                30001..39999, 30001..49999, 400001..465535:
	                    #tmp_len := DINT_TO_UINT( #bytes / 2 );
	            END_CASE;
	    END_CASE;
	ELSE
	    #tmp_len := #d_len;
	    #bytes := #d_len * 2;
	END_IF;
	
	IF #mb.run.insert THEN // Insert this query.
	    #mb.run.mode := 0; // 0 => read (default)
	    
	    // mb_client and mb_master use modicon convention address.
	    CASE #fc OF
	        1:  // Read output bits             
	            #mb.run.data_addr := 1 + #d_addr;
	        2:  // Read input bits            
	            #mb.run.data_addr := 10001 + #d_addr;
	        3:  // Read holding reg.            
	            #mb.run.data_addr := 400001 + #d_addr;
	        4:  // Read input word            
	            #mb.run.data_addr := 30001 + #d_addr;
	        5:  // Writing a single output bit
	            #mb.run.mode := 1;
	            #mb.run.data_addr := 1 + #d_addr;
	        6:  // Writing a single holding register
	            #mb.run.mode := 1;
	            #mb.run.data_addr := 400001 + #d_addr;
	        15: // Writing multiple output bits
	            #mb.run.mode := 2;
	            #mb.run.data_addr := 1 + #d_addr;
	        16: // Writing multiple holding registers
	            #mb.run.mode := 2;
	            #mb.run.data_addr := 400001 + #d_addr;
	        200..202: // Siemens mode 0-2 replaced by 200-202
	            #mb.run.mode := #fc - 200;
	            #mb.run.data_addr := #d_addr;
	        ELSE
	            #mb.run.mode := #fc;
	            #mb.run.data_addr := #d_addr;
	    END_CASE;
	    #mb.q.unit := #unit;
	    #mb.q.fc := #fc;
	    #mb.q.d_addr := #d_addr;
	    #mb.q.d_len := #tmp_len;
	    IF (#mb.run.mode = 1 OR #mb.run.mode = 2) // If it's a write query
	        AND #mb.conf.buffer_handler
	    THEN
	        // Copy the content from "#data" to the buffer.
	        "mb_buffer_handler"(
	            action := 2, // write
	            buffer_db := #mb.fix.buffer_db,
	            data := #data ,
	            bytes := #bytes );
	    END_IF;
	    #mb.run.insert := false;
	    #mb.device.insert_id := #mb.device.insert_id + 1;
	    
	// if the query is finnished.    
	ELSIF #mb.status.done OR #mb.status.error THEN
	    
	    // Make sure that the query resault really belong to this query.   
	    IF #mb.q.unit = #unit
	        AND #mb.q.fc = #fc
	        AND #mb.q.d_addr = #d_addr
	        AND #mb.q.d_len = #tmp_len
	    THEN
	        IF #mb.status.done THEN // Successfully            
	            IF #mb.run.mode = 0 // If it's a read query 
	                AND #mb.conf.buffer_handler
	            THEN
	                // Copy the content from the buffer to "#data"
	                "mb_buffer_handler"(
	                    action := 3, // read
	                    buffer_db := #mb.fix.buffer_db,
	                    data := #data,
	                    bytes := #bytes );
	            END_IF;
	            #mb.query_above.done := true;
	        ELSIF #mb.status.error THEN  // failed
	            #mb.query_above.error := true;
	        END_IF;
	        
	        // Temperary store the d_addr for debugging. Picked up
	        // inside mb_device_footer.
	        #mb.device.recived_d_addr := #d_addr;
	        
	        // recive_id is used inside device_header and device_footer.
	        // if change between them, then it can be determined that the
	        // device has receved an answeer from a query.        
	        #mb.device.recive_id := #mb.device.recive_id + 1;
	    ELSE
	        #mb.log.unsync := #mb.log.unsync + 1; // only for logging 
	    END_IF;
	    
	    // Prepare for the next query.
	    #mb.run.insert := true; 
	    #mb.q.qid := #mb.q.qid + 1;
	END_IF;
	
	#mb.conf.buffer_handler := true;
END_FUNCTION

FUNCTION "mb_device_header" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_IN_OUT 
      device : "udt_mb_device";
      mb : "udt_mb";
   END_VAR


BEGIN
	// Device id cnt. The first device has id "1".
	#mb.device.did_cnt := #mb.device.did_cnt + 1;
	
	// Take a snap shot of the recive_id and insert_id.
	#device.intern.insert_id := #mb.device.insert_id;
	#device.intern.recive_id := #mb.device.recive_id;
	// The mb_query FC will change the insert_id or recive_id if a intermediate
	// query between mb_device_header and mb_device_footer has the query-token.
	// By compare insert_id in the mb udt and device udt at the footer, it can
	// be determined if the query-token points at a query belonging to this
	// device. 
	
	// If the query-token points at this device header, or it point to a query
	// in the previous device, that is surrounded by a if-statement and the 
	// statement is now false.
	IF #mb.q.qid > #mb.run.qid_cnt
	    AND #mb.q.qid <= #device.intern.header_qid
	THEN
	    // At the beginning the offset_qid points at the first query of this
	    // device. When it has executed the offset will point at the second
	    // query. When all queries has executed the offset will be reset
	    // back to the first query.
	    #mb.q.qid := #device.intern.header_qid + #device.intern.offset_qid;
	END_IF;
	
	// The code below is reduce the impact of setting a if-statement
	// around queries. The device header occupy one query id.
	#device.intern.header_qid := MAX(IN1 := #mb.run.qid_cnt + 1,
	                                 IN2 := #device.intern.header_qid);
	#mb.run.qid_cnt := #device.intern.header_qid;
	
END_FUNCTION

FUNCTION "mb_device_footer" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_IN_OUT 
      device : "udt_mb_device";
      mb : "udt_mb";
   END_VAR

   VAR_TEMP 
      e : Int;
      rd_sys_t {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;
      tmp_err : Bool;
   END_VAR


BEGIN
	// If the retry-token point at this device, and there is no communication problems
	// then pass on the retry-token to the next device. The retry token tell which device
	// with communication problem that should retry establish communication. 
	#mb.device.did_retry := #mb.device.did_retry
	+ BOOL_TO_UINT(#mb.device.did_retry = #mb.device.did_cnt
	               AND NOT #device.qComError);
	
	// If device is disabled, then reset error flags.
	IF #device.skip_all_queries THEN   
	    #device.qError := false;       
	    #device.intern.timeout_cnt := 0;
	ELSIF #mb.device.recive_id <> #device.intern.recive_id THEN
	    // If there is a query that bellong to this device that has
	    // recvied a resault. (with or withour error)
	    
	    IF #mb.status.done THEN // Logging successfully query        
	        #device.log.done_cnt := #device.log.done_cnt + 1;
	        #e := RD_LOC_T(#device.log.done_dtl);
	        
	        // One successfully query reset the timeout counter.
	        #device.intern.timeout_cnt := 0;  
	    ELSIF #mb.status.error THEN // Logging failed query        
	        #device.log.err_cnt := #device.log.err_cnt + 1;
	        #e := RD_LOC_T(#device.log.err_dtl);
	        #device.log.err_status := #mb.status.status;
	        #device.log.err_d_addr := #mb.device.recived_d_addr;
	        #device.log.err_timeout := #mb.status.timeout;
	        
	        // Increase timeout cnt. if it's a timeout error.
	        // if it's not a timeout error then reset the cnt.
	        #device.intern.timeout_cnt := SEL(G := #mb.status.timeout,
	              IN0 := 0,
	              IN1 := MIN(IN1 := #device.intern.timeout_cnt + 1,
	                         IN2 := 254));
	        #tmp_err := true;
	        #device.qError := true;
	        #e := RD_SYS_T(#device.intern.err_dtl);
	    END_IF;
	    
	    // - If it's this devices that has the retry-token, and a retry has been
	    //   executed. Then set the retry_finished flag.
	    // - The retry-token will be passed on to the next device with communication
	    //   problems (qComError) when the query loop has reach the end.
	    //   (Inside the controller)
	    // - The purpose of the flag is make sure that a retry is only done once
	    //   for each query loop revolution.
	    #mb.device.retry_finished := #mb.device.did_retry = #mb.device.did_cnt;
	    
	    // Only one query for each device for each loop is allowed to be executed.
	    // offset_qid which one. offset_qid is incread by one a query has executed
	    // given no communication problems.
	    #device.intern.offset_qid := #device.intern.offset_qid
	    + BOOL_TO_INT(NOT #mb.status.timeout);
	END_IF;
	
	// If all queries for this device has been executed, then reset offset_qid.
	IF #device.intern.offset_qid >
	    #mb.run.qid_cnt - #device.intern.header_qid
	THEN
	    #device.intern.offset_qid := 1;
	END_IF;
	
	// Error flags handeling. If qError has been set, then there is a tof-timer that keep
	// it high for a certain time. The time can be configured with "device.conf.time_qErrror".
	IF #device.qError THEN
	    #e := RD_SYS_T(#rd_sys_t);
	    #device.qError := #tmp_err OR #device.conf.time_qErrror <> 0
	    AND #rd_sys_t < #device.intern.err_dtl
	    + #device.conf.time_qErrror;
	END_IF;
	// qComError is only set if x repeating timeout errors has occurred.
	#device.qComError := #device.intern.timeout_cnt > #device.conf.max_qComError;
	
	// Several condition that resault in passing on the query-token on to the
	// next device. Skipping all or the rest of the queries for this device:
	// - If this device has one query that have received a result.
	//   (both successfully or failed query)
	// - If qComError is set, and isn't this device turn to try again.  
	// - If the device is not enabled.
	IF #mb.device.recive_id <> #device.intern.recive_id
	    OR #mb.device.insert_id <> #device.intern.insert_id
	        AND (#device.qComError
	            AND (#mb.device.did_retry <> #mb.device.did_cnt
	            OR #mb.device.retry_finished)
	            // retry_finished will be reset in the controller.
	        OR #device.skip_all_queries )
	THEN
	    // Reset        
	    #mb.q.qid := #mb.run.qid_cnt + 1;
	    #mb.run.insert := true;
	    #mb.conf.buffer_handler := true;
	    #mb.query_above.done := false;
	    #mb.query_above.error := false;
	END_IF;
	
END_FUNCTION

FUNCTION_BLOCK "mb_master_controller"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT 
      hardware_id : PORT;   // hardware id
      baud : UDInt := 9600;
      parity : Bool := true;   // enable even parity. false=no parity.
      timeout : Time := T#500ms;
      buffer_db_any : DB_ANY;
   END_VAR

   VAR_OUTPUT 
      qError : Bool;
   END_VAR

   VAR_IN_OUT 
      buffer_variant : Variant;
      mb : "udt_mb";
   END_VAR

   VAR 
      mb_comm_load {OriginalPartName := 'MB_COMM_LOAD'; LibVersion := '2.1'} : MB_COMM_LOAD;
      mb_master {OriginalPartName := 'MB_MASTER'; LibVersion := '2.2'} : MB_MASTER;
      tof_error {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : TOF_TIME;
   END_VAR


BEGIN
	// Init. the hardware.
	#mb_comm_load(REQ := NOT #mb_comm_load.DONE AND NOT #mb_master.BUSY,
	              "PORT" := #hardware_id,
	              BAUD := #baud,
	              PARITY := SEL(G := #parity, IN0 := 0, IN1 := 2),
	              RESP_TO := TIME_TO_UINT(#timeout),
	              MB_DB := #mb_master);
	
	// The core master block.
	#mb_master(REQ := #mb_comm_load.DONE AND NOT #mb_master.BUSY
	           AND NOT #mb.run.insert,
	           MB_ADDR := #mb.q.unit,
	           MODE := #mb.run.mode,
	           DATA_ADDR := #mb.run.data_addr,
	           DATA_LEN := #mb.q.d_len,
	           DONE => #mb.status.done,
	           ERROR => #mb.status.error,
	           STATUS => #mb.status.status,
	           DATA_PTR := #buffer_variant);
	
	// Timeout errors are handled different from other errors.
	#mb.status.timeout := #mb_master.ERROR
	AND #mb_master.STATUS = 16#80C8;
	
	// --------------------------------------------------
	#tof_error(IN := #mb.status.error,
	           PT := #tof_error.PT,
	           Q => #qError);
	#mb.fix.buffer_db := #buffer_db_any;
	
	// If all queries has been executed, then start over again
	// on the first query.
	IF #mb.q.qid > #mb.run.qid_cnt THEN
	    #mb.q.qid := 1;
	    
	    // The retry-id is the device that get to have retry to restoring
	    // communication after the qComError falg is set for the device.
	    // When one query loop has occurred the retry id is incremented. 
	    #mb.device.did_retry := #mb.device.did_retry + 1;
	    
	    // retry_finished is set after one retry has taken place. 
	    // The device that has the retry-token only has one try to make 
	    // successfully query.
	    #mb.device.retry_finished := false;
	    IF #mb.device.did_retry > #mb.device.did_cnt THEN
	        #mb.device.did_retry := 1;
	    END_IF;
	END_IF;
	#mb.run.qid_cnt := 0; // qid_cnt is incremented in every query.
	#mb.device.did_cnt := 0; // did_cnt is incremented in every device header.
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "mb_client_controller"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT 
      "interface_" : HW_ANY;   // Profinet interface id
      conn_id : CONN_OUC := 123;   // connection_id
      remote_ip : Array[1..4] of Byte := 192, 168, 1, 0;
      remote_port : UInt := 502;   // enable even parity
      timeout : Time := T#2s;   // sec
      buffer_db_any : DB_ANY;
   END_VAR

   VAR_OUTPUT 
      qError : Bool;
   END_VAR

   VAR_IN_OUT 
      buffer_variant : Variant;
      mb : "udt_mb";
   END_VAR

   VAR 
      mb_client {OriginalPartName := 'MB_CLIENT'; LibVersion := '4.0'} : MB_CLIENT;
      tcon_ip_v4 {OriginalPartName := 'TCON_IP_v4'; LibVersion := '1.0'} : TCON_IP_v4;
      ton_timeout {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : TON_TIME;
      ton_timeout_q : Bool;
      tdiscon {OriginalPartName := 'T_DISCON'; LibVersion := '2.1'} : TDISCON;
      tdiscon_bool : Bool;
      disconnect : Bool := false;
      tof_error {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : TOF_TIME;
   END_VAR

   VAR_TEMP 
      tmp_reconnect_after : Bool;
   END_VAR


BEGIN
	#tcon_ip_v4.InterfaceId := #"interface_";
	#tcon_ip_v4.ID := #conn_id;
	#tcon_ip_v4.RemoteAddress.ADDR := #remote_ip;
	#tcon_ip_v4.RemotePort := #remote_port;
	
	// If a new download has taken place, and this block is re-initialize,
	// then the mb_client block will output the error code saying that:
	// "Attempt being made to re-establish an existing connection." (80A3).
	// The solution to this problem is to disconnect and then reconnect.
	#tdiscon(REQ := #mb_client.ERROR AND #mb_client.STATUS = 16#80A3,
	         ID := #conn_id);
	IF #tdiscon.BUSY THEN
	    #tdiscon_bool := true;
	ELSIF #tdiscon.DONE THEN
	    #tdiscon_bool := false;
	END_IF;
	
	#mb_client.MB_Unit_ID := UINT_TO_BYTE(#mb.q.unit);
	#mb_client.Rcv_Timeout := UINT_TO_REAL(TIME_TO_UINT(#timeout)) / 1000;
	#mb_client.Blocked_Proc_Timeout := MIN(IN1 := 3,
	                                       IN2 := #mb_client.Rcv_Timeout + 1);
	#mb_client(REQ := NOT #mb_client.BUSY AND NOT #mb.run.insert
	                AND NOT #mb_client.DISCONNECT,
	           DISCONNECT := #disconnect OR #tdiscon_bool,
	           MB_MODE := #mb.run.mode,
	           MB_DATA_ADDR := #mb.run.data_addr,
	           MB_DATA_LEN := #mb.q.d_len,
	           STATUS => #mb.status.status,
	           MB_DATA_PTR := #buffer_variant,
	           CONNECT := #tcon_ip_v4);
	
	// If mb_client is not establish a connection it will not throw
	// timeout error. That's way timeout handled manually bellow.
	#ton_timeout(IN := NOT #mb.run.insert
	             AND (NOT #mb.status.done OR NOT #mb.status.error),
	             PT := #timeout,
	             Q => #ton_timeout_q);
	
	// Timeout errors are handled different from other errors.
	IF #ton_timeout_q THEN
	    #mb.status.done := false;
	    #mb.status.error := true;
	    #mb.status.timeout := true;
	    RESET_TIMER(#ton_timeout);
	ELSE
	    #mb.status.done := #mb_client.DONE;
	    #mb.status.error := #mb_client.ERROR;
	    #mb.status.timeout := #mb.status.error
	        AND (#mb.status.status = 16#818C
	        OR #mb.status.status = 16#80C8);
	END_IF;
	
	// --------------------------------------------------
	#tof_error(IN := #mb.status.error,
	           PT := #tof_error.PT,
	           Q => #qError);
	#mb.fix.buffer_db := #buffer_db_any;
	
	// If all queries has been executed, then start over again
	// on the first query.
	IF #mb.q.qid > #mb.run.qid_cnt THEN
	    #mb.q.qid := 1;
	    
	    // The retry-id is the device that get to have retry to restoring
	    // communication after the qComError falg is set for the device.
	    // When one query loop has occurred the retry id is incremented. 
	    #mb.device.did_retry := #mb.device.did_retry + 1;
	    
	    // retry_finished is set after one retry has taken place. 
	    // The device that has the retry-token only has one try to make 
	    // successfully query.
	    #mb.device.retry_finished := false;
	    IF #mb.device.did_retry > #mb.device.did_cnt THEN
	        #mb.device.did_retry := 1;
	    END_IF;
	END_IF;
	#mb.run.qid_cnt := 0; // qid_cnt is incremented in every query.
	#mb.device.did_cnt := 0; // did_cnt is incremented in every device header.
	
END_FUNCTION_BLOCK

FUNCTION "mb_log_words" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      in : Word;
   END_VAR

   VAR_IN_OUT 
      log : Variant;
   END_VAR

   VAR_TEMP 
      c : Int;
      w : Word;
      e : Int;
   END_VAR


BEGIN
	// Log keep all the diffrent values of "in". If a value of "in"
	// acceding more then once just the first event will be logged.
	
	FOR #c := 0 TO UDINT_TO_INT(CountOfElements(#log)) - 1 DO
	    #e := MOVE_BLK_VARIANT(SRC := #log, COUNT := 1,SRC_INDEX := #c,
	                           DEST_INDEX := 0, DEST => #w);
	    IF #w = #in THEN
	        EXIT;
	    ELSIF #w = 0 THEN
	        #e := MOVE_BLK_VARIANT(SRC := #in, COUNT := 1, SRC_INDEX := 0,
	                               DEST_INDEX := #c, DEST => #log);
	        EXIT;
	    END_IF;
	END_FOR;
	
END_FUNCTION

